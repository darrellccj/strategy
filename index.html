<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Growth Investing Simulator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Times New Roman', Times, Georgia, serif;
      background: #faf8f5;
      color: #3d3929;
      min-height: 100vh;
      padding: 16px 16px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      color: #5c5340;
      margin-bottom: 2px;
      text-align: center;
    }

    .disclaimer {
      font-size: 0.7rem;
      color: #9a8d79;
      text-align: center;
      margin-bottom: 8px;
    }

    .card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
      box-shadow: 0 2px 8px rgba(92, 83, 64, 0.08);
    }

    .input-group {
      margin-bottom: 18px;
    }

    .input-group:last-child {
      margin-bottom: 0;
    }

    label {
      display: block;
      font-size: 0.9rem;
      font-weight: 500;
      color: #6b5f4d;
      margin-bottom: 8px;
    }

    /* Ticker Search */
    .ticker-search-wrapper {
      position: relative;
    }

    .ticker-search {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid #e5e0d5;
      border-radius: 10px;
      font-size: 1.1rem;
      color: #3d3929;
      background: #faf8f5;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .ticker-search:focus {
      outline: none;
      border-color: #a08c6d;
    }

    .ticker-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #ffffff;
      border: 2px solid #e5e0d5;
      border-top: none;
      border-radius: 0 0 10px 10px;
      max-height: 240px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(92, 83, 64, 0.12);
    }

    .ticker-dropdown.open {
      display: block;
    }

    .ticker-option {
      padding: 12px 16px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.15s ease;
    }

    .ticker-option:hover {
      background: #f0ebe2;
    }

    .ticker-option .ticker-symbol {
      font-weight: 600;
      color: #5c5340;
      font-size: 1rem;
    }

    .ticker-option .ticker-name {
      font-size: 0.85rem;
      color: #9a8d79;
    }

    .ticker-search.has-focus {
      border-radius: 10px 10px 0 0;
    }

    /* Strategy Dropdown */
    .strategy-select-wrapper {
      position: relative;
    }

    .strategy-select-btn {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid #e5e0d5;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 500;
      color: #3d3929;
      background: #faf8f5;
      cursor: pointer;
      font-family: inherit;
      text-align: left;
      transition: border-color 0.2s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .strategy-select-btn:hover {
      border-color: #a08c6d;
    }

    .strategy-select-btn.open {
      border-radius: 10px 10px 0 0;
      border-color: #a08c6d;
    }

    .strategy-select-btn .arrow {
      font-size: 0.7rem;
      transition: transform 0.2s ease;
      color: #9a8d79;
    }

    .strategy-select-btn.open .arrow {
      transform: rotate(180deg);
    }

    .strategy-select-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #ffffff;
      border: 2px solid #a08c6d;
      border-top: none;
      border-radius: 0 0 10px 10px;
      max-height: 320px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(92, 83, 64, 0.12);
    }

    .strategy-select-dropdown.open {
      display: block;
    }

    .strategy-option {
      padding: 12px 16px;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .strategy-option:hover {
      background: #f0ebe2;
    }

    .strategy-option.selected {
      background: #f0ebe2;
    }

    .strategy-option .so-name {
      font-weight: 500;
      color: #5c5340;
      font-size: 0.95rem;
    }

    .strategy-option .so-desc {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 2px;
    }

    /* Amount Input */
    .amount-input-wrapper {
      position: relative;
    }

    .currency-symbol {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      color: #a08c6d;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .amount-input {
      width: 100%;
      padding: 14px 16px 14px 36px;
      border: 2px solid #e5e0d5;
      border-radius: 10px;
      font-size: 1.1rem;
      color: #3d3929;
      background: #faf8f5;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .amount-input:focus {
      outline: none;
      border-color: #a08c6d;
    }

    .amount-hint {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 6px;
    }

    /* Time Slider */
    .slider-container {
      padding: 0 4px;
    }

    .time-slider {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #e5e0d5;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }

    .time-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #a08c6d;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(92, 83, 64, 0.3);
      transition: transform 0.2s ease;
    }

    .time-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .time-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #a08c6d;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(92, 83, 64, 0.3);
    }

    .slider-value {
      text-align: center;
      font-size: 1.5rem;
      font-weight: 600;
      color: #5c5340;
      margin-top: 12px;
    }

    .slider-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 8px;
    }

    /* Results Section */
    .results-card {
      background: linear-gradient(135deg, #f5f0e8 0%, #ebe5d9 100%);
    }

    .results-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .result-item {
      background: #ffffff;
      padding: 12px;
      border-radius: 12px;
    }

    .result-item.full-width {
      grid-column: 1 / -1;
    }

    .result-label {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-bottom: 6px;
    }

    .result-value {
      font-size: 1.4rem;
      font-weight: 600;
      color: #5c5340;
    }

    .result-value.positive {
      color: #5a7a5a;
    }

    .result-value.negative {
      color: #8b5a5a;
    }

    .result-subtext {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 4px;
    }

    /* Chart */
    .chart-container {
      background: #ffffff;
      border-radius: 12px;
      padding: 12px;
    }

    .chart-title {
      font-size: 0.85rem;
      color: #6b5f4d;
      margin-bottom: 12px;
      font-weight: 500;
    }

    canvas {
      width: 100%;
      height: 200px;
    }

    .chart-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 12px;
      font-size: 0.8rem;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .legend-dot.typical { background: #a08c6d; }

    /* Loading state */
    .loading {
      opacity: 0.5;
      pointer-events: none;
    }

    .stock-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: #f0ebe2;
      border-radius: 10px;
      margin-top: 10px;
    }

    .stock-price {
      font-size: 1.2rem;
      font-weight: 600;
      color: #5c5340;
    }

    .stock-change {
      font-size: 0.9rem;
      font-weight: 500;
    }

    .stock-change.positive { color: #5a7a5a; }
    .stock-change.negative { color: #8b5a5a; }

    .data-source {
      font-size: 0.7rem;
      color: #9a8d79;
      text-align: center;
      margin-top: 16px;
    }

    .error-message {
      background: #f8e8e8;
      color: #8b5a5a;
      padding: 12px;
      border-radius: 8px;
      font-size: 0.85rem;
      margin-top: 10px;
    }

    /* Portfolio Builder */
    .portfolio-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 12px;
    }

    .portfolio-entry {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      background: #f0ebe2;
      border-radius: 10px;
    }

    .portfolio-entry .pe-symbol {
      font-weight: 600;
      color: #5c5340;
      font-size: 0.95rem;
      min-width: 50px;
    }

    .portfolio-entry .pe-name {
      flex: 1;
      font-size: 0.8rem;
      color: #9a8d79;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .portfolio-alloc-input {
      width: 58px;
      padding: 6px 4px;
      border: 2px solid #e5e0d5;
      border-radius: 6px;
      font-size: 0.9rem;
      color: #3d3929;
      background: #ffffff;
      font-family: inherit;
      text-align: center;
      transition: border-color 0.2s ease;
    }

    .portfolio-alloc-input:focus {
      outline: none;
      border-color: #a08c6d;
    }

    .pe-pct-label {
      font-size: 0.85rem;
      color: #9a8d79;
    }

    .remove-ticker-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: #9a8d79;
      font-size: 1.2rem;
      cursor: pointer;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .remove-ticker-btn:hover {
      background: #e8d8d0;
      color: #8b5a5a;
    }

    .allocation-bar {
      height: 6px;
      background: #e5e0d5;
      border-radius: 3px;
      margin-bottom: 4px;
      overflow: hidden;
    }

    .allocation-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s ease, background 0.3s ease;
    }

    .allocation-fill.ok {
      background: #5a7a5a;
    }

    .allocation-fill.over {
      background: #8b5a5a;
    }

    .allocation-fill.under {
      background: #a08c6d;
    }

    .allocation-status {
      font-size: 0.75rem;
      color: #9a8d79;
      margin-bottom: 12px;
      text-align: right;
    }

    .allocation-status.warn {
      color: #8b5a5a;
    }

    .add-ticker-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      margin-bottom: 12px;
    }

    .add-ticker-row .ticker-search-wrapper {
      flex: 1;
    }

    .add-ticker-row .ticker-search {
      padding: 10px 12px;
      font-size: 0.95rem;
    }

    .add-ticker-btn {
      padding: 10px 16px;
      border: 2px solid #a08c6d;
      background: #a08c6d;
      color: #ffffff;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .add-ticker-btn:hover {
      background: #8a7760;
      border-color: #8a7760;
    }

    .add-ticker-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .portfolio-empty {
      text-align: center;
      color: #9a8d79;
      font-size: 0.9rem;
      padding: 16px;
    }

    /* Breakdown Section */
    .breakdown-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 10px;
      margin-top: 16px;
      background: #ffffff;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      color: #6b5f4d;
      font-family: inherit;
      width: 100%;
      transition: background 0.15s ease;
    }

    .breakdown-toggle:hover {
      background: #f0ebe2;
    }

    .breakdown-toggle .arrow {
      transition: transform 0.2s ease;
      font-size: 0.7rem;
    }

    .breakdown-toggle.open .arrow {
      transform: rotate(180deg);
    }

    .breakdown-list {
      display: none;
      margin-top: 12px;
      gap: 10px;
      flex-direction: column;
    }

    .breakdown-list.open {
      display: flex;
    }

    .breakdown-entry {
      background: #ffffff;
      border-radius: 10px;
      padding: 14px;
    }

    .breakdown-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .breakdown-header .bh-ticker {
      font-weight: 600;
      color: #5c5340;
      font-size: 0.95rem;
    }

    .breakdown-header .bh-alloc {
      font-size: 0.8rem;
      color: #9a8d79;
    }

    .breakdown-details {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px 16px;
      font-size: 0.8rem;
    }

    .breakdown-details .bd-label {
      color: #9a8d79;
    }

    .breakdown-details .bd-value {
      color: #5c5340;
      font-weight: 500;
      text-align: right;
    }

    /* Small mobile adjustments */
    @media (max-width: 400px) {
      h1 {
        font-size: 1.5rem;
      }

      .results-grid {
        grid-template-columns: 1fr;
      }

      .result-item.full-width {
        grid-column: 1;
      }

      .portfolio-entry .pe-name {
        display: none;
      }
    }

    /* Desktop layout */
    @media (min-width: 768px) {
      body {
        padding: 40px 32px;
      }

      .container {
        max-width: 1200px;
      }

      h1 {
        font-size: 2rem;
        margin-bottom: 16px;
      }

      .mode-tabs {
        margin-bottom: 24px;
      }

      .main-layout {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
        align-items: start;
      }

      .card {
        padding: 32px;
        margin-bottom: 0;
      }

      .results-card {
        position: sticky;
        top: 40px;
      }

      .input-group {
        margin-bottom: 28px;
      }

      label {
        font-size: 0.95rem;
      }

      .amount-input {
        padding: 16px 16px 16px 40px;
        font-size: 1.2rem;
      }

      .currency-symbol {
        font-size: 1.2rem;
        left: 18px;
      }

      .slider-value {
        font-size: 1.75rem;
      }

      .result-value {
        font-size: 1.6rem;
      }

      .chart-container {
        padding: 20px;
      }

      canvas {
        height: 240px;
      }
    }

    /* Mode Tabs */
    .mode-tabs {
      display: flex;
      justify-content: center;
      gap: 0;
      margin-bottom: 16px;
      background: #e5e0d5;
      border-radius: 10px;
      padding: 3px;
      max-width: 300px;
      margin-left: auto;
      margin-right: auto;
    }

    .mode-tab {
      flex: 1;
      padding: 8px 16px;
      border: none;
      background: transparent;
      color: #6b5f4d;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      font-family: inherit;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .mode-tab.active {
      background: #a08c6d;
      color: #ffffff;
    }

    .mode-tab:hover:not(.active) {
      background: rgba(160, 140, 109, 0.2);
    }

    /* Optimize Card */
    .optimize-card {
      display: none;
    }

    .optimize-card.visible {
      display: block;
    }

    .optimize-results-card {
      display: none;
    }

    .optimize-results-card.visible {
      display: block;
    }

    .target-input-wrapper {
      position: relative;
    }

    .target-input {
      width: 100%;
      padding: 14px 40px 14px 16px;
      border: 2px solid #e5e0d5;
      border-radius: 10px;
      font-size: 1.1rem;
      color: #3d3929;
      background: #faf8f5;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .target-input:focus {
      outline: none;
      border-color: #a08c6d;
    }

    .target-suffix {
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      color: #a08c6d;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .complexity-btns {
      display: flex;
      gap: 0;
      background: #e5e0d5;
      border-radius: 10px;
      padding: 3px;
    }

    .complexity-btn {
      flex: 1;
      padding: 8px 8px;
      border: none;
      background: transparent;
      color: #6b5f4d;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      font-family: inherit;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .complexity-btn.active {
      background: #a08c6d;
      color: #ffffff;
    }

    .complexity-btn:hover:not(.active) {
      background: rgba(160, 140, 109, 0.2);
    }

    .run-optimize-btn {
      width: 100%;
      padding: 14px 16px;
      border: none;
      background: #5a7a5a;
      color: #ffffff;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s ease;
      margin-top: 8px;
    }

    .run-optimize-btn:hover {
      background: #4a6a4a;
    }

    .run-optimize-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .optimize-status {
      margin-top: 12px;
      text-align: center;
      font-size: 0.85rem;
      color: #6b5f4d;
      display: none;
    }

    .optimize-status.visible {
      display: block;
    }

    .optimize-progress-bar {
      height: 6px;
      background: #e5e0d5;
      border-radius: 3px;
      margin-top: 8px;
      overflow: hidden;
    }

    .optimize-progress-fill {
      height: 100%;
      background: #5a7a5a;
      border-radius: 3px;
      transition: width 0.2s ease;
      width: 0%;
    }

    /* Optimize Results */
    .optimize-empty {
      text-align: center;
      color: #9a8d79;
      font-size: 0.9rem;
      padding: 32px 16px;
    }

    .optimize-result-item {
      background: #ffffff;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 10px;
    }

    .ori-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .ori-rank {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: #a08c6d;
      color: #ffffff;
      font-size: 0.8rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .ori-strategy {
      font-weight: 600;
      color: #5c5340;
      font-size: 0.95rem;
      flex: 1;
    }

    .ori-diff {
      font-size: 0.75rem;
      font-weight: 500;
      color: #9a8d79;
      white-space: nowrap;
    }

    .ori-diff.positive {
      color: #5a7a5a;
    }

    .ori-diff.negative {
      color: #8b5a5a;
    }

    .ori-metrics {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 10px;
    }

    .ori-metric {
      background: #faf8f5;
      padding: 8px 10px;
      border-radius: 8px;
    }

    .ori-metric-label {
      font-size: 0.7rem;
      color: #9a8d79;
      margin-bottom: 2px;
    }

    .ori-metric-value {
      font-size: 0.95rem;
      font-weight: 600;
      color: #5c5340;
    }

    .ori-metric-value.positive {
      color: #5a7a5a;
    }

    .ori-metric-value.negative {
      color: #8b5a5a;
    }

    .ori-allocations {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .ori-chip {
      display: inline-block;
      padding: 4px 10px;
      background: #f0ebe2;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
      color: #5c5340;
    }

    /* Large desktop */
    @media (min-width: 1024px) {
      .main-layout {
        gap: 32px;
      }

      .card {
        padding: 36px;
        border-radius: 20px;
      }

      .result-item {
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Growth Investing Simulator</h1>
    <p class="disclaimer">Past performance does not guarantee future results.</p>

    <div class="mode-tabs">
      <button class="mode-tab active" data-mode="simulate">Simulate</button>
      <button class="mode-tab" data-mode="optimize">Optimize</button>
    </div>

    <div class="main-layout" id="simulate-layout">
    <div class="card">
      <div class="input-group">
        <label>Portfolio</label>
        <div class="add-ticker-row">
          <div class="ticker-search-wrapper">
            <input type="text" class="ticker-search" id="ticker-search" placeholder="Add a stock (e.g. AAPL)" autocomplete="off">
            <div class="ticker-dropdown" id="ticker-dropdown"></div>
          </div>
          <button class="add-ticker-btn" id="add-ticker-btn" disabled>+</button>
        </div>
        <div id="portfolio-list" class="portfolio-list"></div>
        <div class="allocation-bar"><div class="allocation-fill ok" id="allocation-fill"></div></div>
        <div class="allocation-status" id="allocation-status">Total: 100%</div>
      </div>

      <div class="input-group">
        <label>Strategy</label>
        <div class="strategy-select-wrapper">
          <button class="strategy-select-btn" id="strategy-select-btn">
            <span id="strategy-btn-text">Monthly DCA</span>
            <span class="arrow">&#9660;</span>
          </button>
          <div class="strategy-select-dropdown" id="strategy-dropdown"></div>
        </div>
      </div>

      <div class="input-group">
        <label id="amount-label">Monthly Amount</label>
        <div class="amount-input-wrapper">
          <span class="currency-symbol">$</span>
          <input type="text" class="amount-input" id="amount" value="500" inputmode="numeric">
        </div>
        <div class="amount-hint" id="amount-hint">Amount you'll invest each month</div>
      </div>

      <div class="input-group">
        <label>If you started investing...</label>
        <div class="slider-container">
          <input type="range" class="time-slider" id="years" min="1" max="10" value="5">
          <div class="slider-value"><span id="years-display">5</span> years ago</div>
          <div class="slider-labels">
            <span>1 year ago</span>
            <span>10 years ago</span>
          </div>
        </div>
      </div>
    </div>

    <div class="card results-card">
      <div class="results-grid">
        <div class="result-item">
          <div class="result-label">Total Contributed</div>
          <div class="result-value" id="total-contributed">$0</div>
        </div>

        <div class="result-item">
          <div class="result-label">Value Today</div>
          <div class="result-value" id="final-value">$0</div>
          <div class="result-subtext" id="profit-text">Profit: $0</div>
        </div>

        <div class="result-item">
          <div class="result-label">Max Drawdown</div>
          <div class="result-value negative" id="max-drawdown">-0%</div>
        </div>

        <div class="result-item">
          <div class="result-label">Annualized Return</div>
          <div class="result-value" id="total-return">0%</div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">Historical Portfolio Value</div>
        <canvas id="chart"></canvas>
        <div class="chart-legend">
          <div class="legend-item">
            <div class="legend-dot typical"></div>
            <span>Portfolio Value</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #d4cfc4;"></div>
            <span>Total Invested</span>
          </div>
        </div>
        <div class="data-source">Data from Yahoo Finance. Past performance doesn't guarantee future results.</div>
      </div>

      <button class="breakdown-toggle" id="breakdown-toggle" style="display:none;">
        Per-Ticker Breakdown <span class="arrow">&#9660;</span>
      </button>
      <div class="breakdown-list" id="breakdown-list"></div>
    </div>
    </div>

    <!-- Optimize Mode -->
    <div class="main-layout" id="optimize-layout" style="display:none;">
    <div class="card optimize-card visible">
      <div class="input-group">
        <label>Target Annual Return</label>
        <div class="target-input-wrapper">
          <input type="text" class="target-input" id="optimize-target" value="15" inputmode="numeric">
          <span class="target-suffix">%/yr</span>
        </div>
      </div>

      <div class="input-group">
        <label>Backtest Period</label>
        <div class="slider-container">
          <input type="range" class="time-slider" id="optimize-years" min="1" max="10" value="5">
          <div class="slider-value"><span id="optimize-years-display">5</span> years ago</div>
          <div class="slider-labels">
            <span>1 year ago</span>
            <span>10 years ago</span>
          </div>
        </div>
      </div>

      <div class="input-group">
        <label>Portfolio Complexity</label>
        <div class="complexity-btns">
          <button class="complexity-btn active" data-complexity="1">Single Asset</button>
          <button class="complexity-btn" data-complexity="2">2 Assets</button>
          <button class="complexity-btn" data-complexity="3">3 Assets</button>
        </div>
      </div>

      <button class="run-optimize-btn" id="run-optimize-btn">Find Best Portfolios</button>

      <div class="optimize-status" id="optimize-status">
        <span id="optimize-status-text">Testing portfolio 0 of 0 (0%)</span>
        <div class="optimize-progress-bar">
          <div class="optimize-progress-fill" id="optimize-progress-fill"></div>
        </div>
      </div>
    </div>

    <div class="card results-card optimize-results-card visible" id="optimize-results-card">
      <div id="optimize-results-container">
        <div class="optimize-empty">Click "Find Best Portfolios" to start</div>
      </div>
    </div>
    </div>
  </div>

  <script>
    // Available tickers
    const TICKERS = [
      { symbol: 'AAPL', yahoo: 'AAPL', name: 'Apple' },
      { symbol: 'MSFT', yahoo: 'MSFT', name: 'Microsoft' },
      { symbol: 'GOOGL', yahoo: 'GOOGL', name: 'Alphabet (Google)' },
      { symbol: 'AMZN', yahoo: 'AMZN', name: 'Amazon' },
      { symbol: 'META', yahoo: 'META', name: 'Meta Platforms' },
      { symbol: 'NVDA', yahoo: 'NVDA', name: 'Nvidia' },
      { symbol: 'TSLA', yahoo: 'TSLA', name: 'Tesla' },
      { symbol: 'GLD', yahoo: 'GLD', name: 'SPDR Gold Trust' },
      { symbol: 'SLV', yahoo: 'SLV', name: 'iShares Silver Trust' },
      { symbol: 'VOO', yahoo: 'VOO', name: 'Vanguard S&P 500 ETF' },
      { symbol: 'SPY', yahoo: 'SPY', name: 'SPDR S&P 500 ETF' },
      { symbol: 'BTC', yahoo: 'BTC-USD', name: 'Bitcoin' },
      { symbol: 'ETH', yahoo: 'ETH-USD', name: 'Ethereum' },
    ];

    // Strategy configuration
    const STRATEGIES = {
      dca:          { name: 'Monthly DCA',        desc: 'Buy a fixed amount every month',                   amountLabel: 'Monthly Amount',        amountHint: "Amount you'll invest each month",                          defaultAmount: 500 },
      lump:         { name: 'Lump Sum',            desc: 'Invest everything at once',                        amountLabel: 'Initial Investment',    amountHint: 'One-time investment amount',                               defaultAmount: 10000 },
      ema50:        { name: '50 EMA Touch',        desc: 'Buy when price touches 50-day EMA',                amountLabel: 'Buy Amount per Signal', amountHint: 'Amount to invest each time price touches 50 EMA',         defaultAmount: 1000 },
      ema100:       { name: '100 EMA Touch',       desc: 'Buy when price touches 100-day EMA',               amountLabel: 'Buy Amount per Signal', amountHint: 'Amount to invest each time price touches 100 EMA',        defaultAmount: 1000 },
      ema200:       { name: '200 EMA Touch',       desc: 'Buy when price touches 200-day EMA',               amountLabel: 'Buy Amount per Signal', amountHint: 'Amount to invest each time price touches 200 EMA',        defaultAmount: 1000 },
      emaCrossover: { name: 'EMA Crossover',       desc: 'Buy on golden cross (50 EMA crosses above 200)',   amountLabel: 'Buy Amount per Signal', amountHint: 'Amount to invest on each golden cross signal',            defaultAmount: 5000 },
      rsi:          { name: 'RSI Mean Reversion',  desc: 'Buy when RSI drops below 30 (oversold)',           amountLabel: 'Buy Amount per Signal', amountHint: 'Amount to invest each time RSI signals oversold',         defaultAmount: 1000 },
      macd:         { name: 'MACD Divergence',     desc: 'Buy on bullish MACD crossover',                    amountLabel: 'Buy Amount per Signal', amountHint: 'Amount to invest on each bullish MACD crossover',         defaultAmount: 1000 },
    };

    // State
    let state = {
      portfolio: [
        { symbol: 'VOO', yahoo: 'VOO', name: 'Vanguard S&P 500 ETF', allocation: 100, data: null }
      ],
      style: 'dca',
      amount: 500,
      years: 5,
      mode: 'simulate',
      optimizeTargetReturn: 15,
      optimizeYears: 5,
      optimizeComplexity: 1
    };

    // Pending ticker for adding to portfolio
    let pendingTicker = null;

    // Cache for ticker data
    const dataCache = {};

    // Pre-fetched data
    let bundledDataLoaded = false;
    let bundledDataPromise = null;
    let dailyDataLoaded = false;
    let dailyDataPromise = null;
    let dailyDataCache = {};

    async function loadBundledData() {
      try {
        const res = await fetch('data.json');
        if (!res.ok) throw new Error('data.json not found');
        const json = await res.json();
        if (json.tickers) {
          for (const [yahooTicker, tickerData] of Object.entries(json.tickers)) {
            dataCache[yahooTicker] = {
              ticker: yahooTicker,
              name: tickerData.name,
              currentPrice: tickerData.currentPrice,
              priceChange: tickerData.priceChange,
              percentChange: tickerData.percentChange,
              currency: tickerData.currency || 'USD',
              dailyData: []
            };
          }
        }
      } catch (e) {
        // data.json not available
      }
      bundledDataLoaded = true;
    }

    async function loadDailyData() {
      try {
        const res = await fetch('daily-data.json');
        if (!res.ok) throw new Error('daily-data.json not found');
        const json = await res.json();
        if (json.tickers) {
          for (const [yahooTicker, entries] of Object.entries(json.tickers)) {
            const dailyData = entries.map(d => ({
              date: new Date(d.date + 'T00:00:00Z'),
              price: d.price
            }));
            dailyDataCache[yahooTicker] = dailyData;
            // Merge into main cache if entry exists
            if (dataCache[yahooTicker]) {
              dataCache[yahooTicker].dailyData = dailyData;
            }
          }
        }
      } catch (e) {
        // daily-data.json not available
      }
      dailyDataLoaded = true;
    }

    // DOM Elements
    const tickerSearch = document.getElementById('ticker-search');
    const tickerDropdown = document.getElementById('ticker-dropdown');
    const addTickerBtn = document.getElementById('add-ticker-btn');
    const portfolioListEl = document.getElementById('portfolio-list');
    const allocationFill = document.getElementById('allocation-fill');
    const allocationStatus = document.getElementById('allocation-status');
    const amountInput = document.getElementById('amount');
    const amountLabel = document.getElementById('amount-label');
    const amountHint = document.getElementById('amount-hint');
    const yearsSlider = document.getElementById('years');
    const yearsDisplay = document.getElementById('years-display');
    const resultsCard = document.querySelector('.results-card');
    const breakdownToggle = document.getElementById('breakdown-toggle');
    const breakdownList = document.getElementById('breakdown-list');
    const strategySelectBtn = document.getElementById('strategy-select-btn');
    const strategyBtnText = document.getElementById('strategy-btn-text');
    const strategyDropdown = document.getElementById('strategy-dropdown');

    // Format currency
    function formatCurrency(value) {
      if (value >= 1000000) {
        return '$' + (value / 1000000).toFixed(2) + 'M';
      }
      return '$' + Math.round(value).toLocaleString();
    }

    // Format percentage
    function formatPercent(value) {
      const sign = value >= 0 ? '+' : '';
      return sign + value.toFixed(1) + '%';
    }

    // CORS proxies to try in order
    const CORS_PROXIES = [
      (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
    ];

    // Fetch with CORS proxy fallback
    async function fetchWithProxy(url) {
      for (const proxyFn of CORS_PROXIES) {
        try {
          const proxyUrl = proxyFn(url);
          const response = await fetch(proxyUrl);
          if (response.ok) {
            return await response.json();
          }
        } catch (e) {
          continue;
        }
      }
      throw new Error('All proxies failed');
    }

    // Fetch stock data from Yahoo Finance
    async function fetchStockData(yahooTicker) {
      // Load bundled data on first call
      if (!bundledDataLoaded) {
        if (!bundledDataPromise) bundledDataPromise = loadBundledData();
        await bundledDataPromise;
      }
      if (!dailyDataLoaded) {
        if (!dailyDataPromise) dailyDataPromise = loadDailyData();
        await dailyDataPromise;
      }

      // Check cache (may have been populated from bundled data)
      if (dataCache[yahooTicker] && dataCache[yahooTicker].dailyData && dataCache[yahooTicker].dailyData.length > 0) {
        return dataCache[yahooTicker];
      }

      // Merge daily data from separate cache if available
      if (dataCache[yahooTicker] && dailyDataCache[yahooTicker]) {
        dataCache[yahooTicker].dailyData = dailyDataCache[yahooTicker];
        return dataCache[yahooTicker];
      }

      const dailyUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${yahooTicker}?range=2d&interval=1d&includePrePost=false`;
      const dailyHistoryUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${yahooTicker}?range=10y&interval=1d&includePrePost=false`;

      try {
        const [dailyData, dailyHistoryData] = await Promise.all([
          fetchWithProxy(dailyUrl).catch(() => null),
          fetchWithProxy(dailyHistoryUrl).catch(() => null)
        ]);

        let currentPrice = 0;
        let priceChange = 0;
        let percentChange = 0;
        let name = yahooTicker;

        // Build daily history data
        let dailyHistoryArr = [];
        if (dailyHistoryData && dailyHistoryData.chart && dailyHistoryData.chart.result && dailyHistoryData.chart.result[0]) {
          const dResult = dailyHistoryData.chart.result[0];
          const meta = dResult.meta;
          const dQuotes = dResult.indicators.quote[0];
          const dTimestamps = dResult.timestamp;
          currentPrice = meta.regularMarketPrice;
          name = meta.shortName || meta.symbol;

          for (let j = 0; j < dTimestamps.length; j++) {
            if (dQuotes.close[j] !== null) {
              dailyHistoryArr.push({
                date: new Date(dTimestamps[j] * 1000),
                price: dQuotes.close[j]
              });
            }
          }
          // Update last entry with current price
          if (dailyHistoryArr.length > 0) {
            dailyHistoryArr[dailyHistoryArr.length - 1].price = currentPrice;
          }
        }

        // Extract daily change
        if (dailyData && dailyData.chart && dailyData.chart.result && dailyData.chart.result[0]) {
          const meta = dailyData.chart.result[0].meta;
          if (!currentPrice) currentPrice = meta.regularMarketPrice;
          if (!name || name === yahooTicker) name = meta.shortName || meta.symbol;
          const dailyQuotes = dailyData.chart.result[0].indicators.quote[0];
          const closes = dailyQuotes.close.filter(c => c !== null);
          if (closes.length >= 2) {
            const prevClose = closes[closes.length - 2];
            priceChange = currentPrice - prevClose;
            percentChange = (priceChange / prevClose) * 100;
          }
        }

        if (dailyHistoryArr.length === 0) throw new Error('No daily data');

        const tickerData = {
          ticker: yahooTicker,
          name,
          currentPrice,
          priceChange,
          percentChange,
          dailyData: dailyHistoryArr,
          currency: 'USD'
        };

        dataCache[yahooTicker] = tickerData;
        return tickerData;
      } catch (error) {
        console.error('Error fetching stock data:', error);
        return getFallbackData(yahooTicker);
      }
    }

    // Fallback data if API fails
    function getFallbackData(ticker) {
      return {
        ticker,
        name: ticker,
        currentPrice: 0,
        priceChange: 0,
        percentChange: 0,
        dailyData: [],
        isFallback: true
      };
    }

    // --- Utility: slice daily data from cutoff ---
    function sliceDailyFromYearsAgo(dailyData, yearsAgo) {
      const now = new Date();
      const cutoffDate = new Date(now);
      cutoffDate.setFullYear(cutoffDate.getFullYear() - yearsAgo);
      let startIdx = 0;
      for (let i = 0; i < dailyData.length; i++) {
        if (dailyData[i].date >= cutoffDate) {
          startIdx = i;
          break;
        }
      }
      return dailyData.slice(startIdx);
    }

    // --- Max drawdown helper ---
    function computeMaxDrawdown(portfolioValues) {
      let peak = 0;
      let maxDrawdown = 0;
      for (const pv of portfolioValues) {
        if (pv.value > peak) peak = pv.value;
        if (peak > 0) {
          const dd = (pv.value - peak) / peak;
          if (dd < maxDrawdown) maxDrawdown = dd;
        }
      }
      return maxDrawdown * 100;
    }

    // --- Chart sampling utility ---
    function sampleForChart(portfolioValues, targetPoints = 120) {
      if (portfolioValues.length <= targetPoints) return portfolioValues;
      const sampled = [];
      for (let i = 0; i < targetPoints; i++) {
        const idx = Math.round((i / (targetPoints - 1)) * (portfolioValues.length - 1));
        sampled.push(portfolioValues[idx]);
      }
      return sampled;
    }

    // Backtest DCA strategy with daily data
    function backtestDCA(dailyData, monthlyAmount, yearsAgo) {
      const relevantData = sliceDailyFromYearsAgo(dailyData, yearsAgo);
      if (relevantData.length < 2) return null;

      let totalShares = 0;
      let totalInvested = 0;
      const portfolioValues = [];
      let lastBuyMonth = -1;
      let lastBuyYear = -1;

      for (let i = 0; i < relevantData.length; i++) {
        const d = relevantData[i].date;
        const price = relevantData[i].price;
        const month = d.getUTCMonth();
        const year = d.getUTCFullYear();

        // Buy on first trading day of each new calendar month
        if (month !== lastBuyMonth || year !== lastBuyYear) {
          const sharesBought = monthlyAmount / price;
          totalShares += sharesBought;
          totalInvested += monthlyAmount;
          lastBuyMonth = month;
          lastBuyYear = year;
        }

        portfolioValues.push({
          date: d,
          value: totalShares * price,
          invested: totalInvested
        });
      }

      const finalPrice = relevantData[relevantData.length - 1].price;
      const finalValue = totalShares * finalPrice;
      const profit = finalValue - totalInvested;
      const returnPercent = ((finalValue - totalInvested) / totalInvested) * 100;

      return {
        totalInvested,
        finalValue,
        profit,
        returnPercent,
        totalShares,
        avgCostPerShare: totalInvested / totalShares,
        maxDrawdown: computeMaxDrawdown(portfolioValues),
        portfolioValues,
        investedValues: portfolioValues.map(v => v.invested)
      };
    }

    // Backtest lump sum strategy with daily data
    function backtestLumpSum(dailyData, amount, yearsAgo) {
      const relevantData = sliceDailyFromYearsAgo(dailyData, yearsAgo);
      if (relevantData.length < 2) return null;

      const buyPrice = relevantData[0].price;
      const shares = amount / buyPrice;
      const portfolioValues = [];

      for (let i = 0; i < relevantData.length; i++) {
        portfolioValues.push({
          date: relevantData[i].date,
          value: shares * relevantData[i].price,
          invested: amount
        });
      }

      const finalPrice = relevantData[relevantData.length - 1].price;
      const finalValue = shares * finalPrice;

      return {
        totalInvested: amount,
        finalValue,
        profit: finalValue - amount,
        returnPercent: ((finalValue - amount) / amount) * 100,
        totalShares: shares,
        avgCostPerShare: buyPrice,
        maxDrawdown: computeMaxDrawdown(portfolioValues),
        portfolioValues,
        investedValues: portfolioValues.map(() => amount)
      };
    }

    // Calculate EMA from daily price data for any period
    function calculateEMA(dailyData, period) {
      if (dailyData.length < period) return [];
      const multiplier = 2 / (period + 1);

      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += dailyData[i].price;
      }
      const emaValues = new Array(period - 1).fill(null);
      let ema = sum / period;
      emaValues.push(ema);

      for (let i = period; i < dailyData.length; i++) {
        ema = (dailyData[i].price - ema) * multiplier + ema;
        emaValues.push(ema);
      }
      return emaValues;
    }

    // Calculate RSI (Wilder's smoothed)
    function calculateRSI(dailyData, period = 14) {
      if (dailyData.length < period + 1) return [];
      const rsiValues = new Array(period).fill(null);

      let avgGain = 0;
      let avgLoss = 0;
      for (let i = 1; i <= period; i++) {
        const change = dailyData[i].price - dailyData[i - 1].price;
        if (change > 0) avgGain += change;
        else avgLoss += Math.abs(change);
      }
      avgGain /= period;
      avgLoss /= period;

      const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
      rsiValues.push(avgLoss === 0 ? 100 : 100 - (100 / (1 + rs)));

      for (let i = period + 1; i < dailyData.length; i++) {
        const change = dailyData[i].price - dailyData[i - 1].price;
        const gain = change > 0 ? change : 0;
        const loss = change < 0 ? Math.abs(change) : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;
        const rs2 = avgLoss === 0 ? 100 : avgGain / avgLoss;
        rsiValues.push(avgLoss === 0 ? 100 : 100 - (100 / (1 + rs2)));
      }
      return rsiValues;
    }

    // Calculate MACD
    function calculateMACD(dailyData, fast = 12, slow = 26, signal = 9) {
      const fastEMA = calculateEMA(dailyData, fast);
      const slowEMA = calculateEMA(dailyData, slow);
      if (fastEMA.length === 0 || slowEMA.length === 0) return null;

      // MACD line = fast EMA - slow EMA
      const macdLine = [];
      for (let i = 0; i < dailyData.length; i++) {
        if (fastEMA[i] === null || slowEMA[i] === null) {
          macdLine.push(null);
        } else {
          macdLine.push(fastEMA[i] - slowEMA[i]);
        }
      }

      // Signal line = EMA of MACD line
      // Build temp array of non-null MACD values for EMA calculation
      const macdNonNull = [];
      const macdIndices = [];
      for (let i = 0; i < macdLine.length; i++) {
        if (macdLine[i] !== null) {
          macdNonNull.push({ price: macdLine[i] });
          macdIndices.push(i);
        }
      }

      const signalRaw = calculateEMA(macdNonNull, signal);
      const signalLine = new Array(dailyData.length).fill(null);
      for (let i = 0; i < signalRaw.length; i++) {
        if (signalRaw[i] !== null) {
          signalLine[macdIndices[i]] = signalRaw[i];
        }
      }

      // Histogram
      const histogram = [];
      for (let i = 0; i < dailyData.length; i++) {
        if (macdLine[i] !== null && signalLine[i] !== null) {
          histogram.push(macdLine[i] - signalLine[i]);
        } else {
          histogram.push(null);
        }
      }

      return { macdLine, signalLine, histogram };
    }

    // Backtest EMA touch strategy (daily tracking)
    function backtestEMA(dailyData, buyAmount, yearsAgo, period = 200) {
      if (!dailyData || dailyData.length < period) return null;

      const now = new Date();
      const cutoffDate = new Date(now);
      cutoffDate.setFullYear(cutoffDate.getFullYear() - yearsAgo);

      const prefetchDays = period + 100;
      const prefetchDate = new Date(cutoffDate);
      prefetchDate.setDate(prefetchDate.getDate() - prefetchDays);

      let prefetchIdx = 0;
      for (let i = 0; i < dailyData.length; i++) {
        if (dailyData[i].date >= prefetchDate) { prefetchIdx = i; break; }
      }

      const slicedDaily = dailyData.slice(prefetchIdx);
      const emaValues = calculateEMA(slicedDaily, period);
      if (emaValues.length === 0) return null;

      let rangeStartIdx = 0;
      for (let i = 0; i < slicedDaily.length; i++) {
        if (slicedDaily[i].date >= cutoffDate) { rangeStartIdx = i; break; }
      }
      if (rangeStartIdx < 1 || rangeStartIdx >= emaValues.length) return null;

      let totalShares = 0;
      let totalInvested = 0;
      let buyCount = 0;
      const buySignals = [];
      const portfolioValues = [];

      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (emaValues[i] !== null && emaValues[i - 1] !== null) {
          const prevPrice = slicedDaily[i - 1].price;
          const prevEMA = emaValues[i - 1];
          const currentPrice = slicedDaily[i].price;
          const currentEMA = emaValues[i];

          if (prevPrice > prevEMA && currentPrice <= currentEMA) {
            totalShares += buyAmount / currentPrice;
            totalInvested += buyAmount;
            buyCount++;
            buySignals.push({ date: slicedDaily[i].date, price: currentPrice });
          }
        }

        portfolioValues.push({
          date: slicedDaily[i].date,
          value: totalShares * slicedDaily[i].price,
          invested: totalInvested
        });
      }

      if (buyCount === 0) return { noSignals: true };

      const lastPrice = slicedDaily[slicedDaily.length - 1].price;
      const finalValue = totalShares * lastPrice;

      const chartEmaData = [];
      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (emaValues[i] !== null) {
          chartEmaData.push({ date: slicedDaily[i].date, price: slicedDaily[i].price, ema: emaValues[i] });
        }
      }

      return {
        totalInvested,
        finalValue,
        profit: finalValue - totalInvested,
        returnPercent: totalInvested > 0 ? ((finalValue - totalInvested) / totalInvested) * 100 : 0,
        totalShares,
        avgCostPerShare: totalInvested / totalShares,
        maxDrawdown: computeMaxDrawdown(portfolioValues),
        portfolioValues,
        investedValues: portfolioValues.map(v => v.invested),
        buyCount,
        buySignals,
        emaData: chartEmaData,
        isEma: true,
        emaPeriod: period
      };
    }

    // Backtest EMA Crossover (golden cross: short EMA crosses above long EMA)
    function backtestEMACrossover(dailyData, buyAmount, yearsAgo, shortPeriod = 50, longPeriod = 200) {
      if (!dailyData || dailyData.length < longPeriod) return null;

      const now = new Date();
      const cutoffDate = new Date(now);
      cutoffDate.setFullYear(cutoffDate.getFullYear() - yearsAgo);

      const prefetchDays = longPeriod + 100;
      const prefetchDate = new Date(cutoffDate);
      prefetchDate.setDate(prefetchDate.getDate() - prefetchDays);

      let prefetchIdx = 0;
      for (let i = 0; i < dailyData.length; i++) {
        if (dailyData[i].date >= prefetchDate) { prefetchIdx = i; break; }
      }

      const slicedDaily = dailyData.slice(prefetchIdx);
      const shortEMA = calculateEMA(slicedDaily, shortPeriod);
      const longEMA = calculateEMA(slicedDaily, longPeriod);
      if (shortEMA.length === 0 || longEMA.length === 0) return null;

      let rangeStartIdx = 0;
      for (let i = 0; i < slicedDaily.length; i++) {
        if (slicedDaily[i].date >= cutoffDate) { rangeStartIdx = i; break; }
      }
      if (rangeStartIdx < 1 || rangeStartIdx >= shortEMA.length || rangeStartIdx >= longEMA.length) return null;

      let totalShares = 0;
      let totalInvested = 0;
      let buyCount = 0;
      const buySignals = [];
      const portfolioValues = [];

      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (shortEMA[i] !== null && longEMA[i] !== null && shortEMA[i - 1] !== null && longEMA[i - 1] !== null) {
          // Golden cross: short was below long, now above
          if (shortEMA[i - 1] <= longEMA[i - 1] && shortEMA[i] > longEMA[i]) {
            totalShares += buyAmount / slicedDaily[i].price;
            totalInvested += buyAmount;
            buyCount++;
            buySignals.push({ date: slicedDaily[i].date, price: slicedDaily[i].price });
          }
        }

        portfolioValues.push({
          date: slicedDaily[i].date,
          value: totalShares * slicedDaily[i].price,
          invested: totalInvested
        });
      }

      if (buyCount === 0) return { noSignals: true };

      const lastPrice = slicedDaily[slicedDaily.length - 1].price;
      const finalValue = totalShares * lastPrice;

      // Build overlay data with both EMAs
      const chartEmaData = [];
      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (shortEMA[i] !== null && longEMA[i] !== null) {
          chartEmaData.push({
            date: slicedDaily[i].date,
            price: slicedDaily[i].price,
            emaShort: shortEMA[i],
            emaLong: longEMA[i]
          });
        }
      }

      return {
        totalInvested,
        finalValue,
        profit: finalValue - totalInvested,
        returnPercent: totalInvested > 0 ? ((finalValue - totalInvested) / totalInvested) * 100 : 0,
        totalShares,
        avgCostPerShare: totalInvested / totalShares,
        maxDrawdown: computeMaxDrawdown(portfolioValues),
        portfolioValues,
        investedValues: portfolioValues.map(v => v.invested),
        buyCount,
        buySignals,
        emaData: chartEmaData,
        isEmaCrossover: true
      };
    }

    // Backtest RSI Mean Reversion
    function backtestRSI(dailyData, buyAmount, yearsAgo, period = 14, threshold = 30) {
      if (!dailyData || dailyData.length < period + 1) return null;

      const now = new Date();
      const cutoffDate = new Date(now);
      cutoffDate.setFullYear(cutoffDate.getFullYear() - yearsAgo);

      const prefetchDays = period + 50;
      const prefetchDate = new Date(cutoffDate);
      prefetchDate.setDate(prefetchDate.getDate() - prefetchDays);

      let prefetchIdx = 0;
      for (let i = 0; i < dailyData.length; i++) {
        if (dailyData[i].date >= prefetchDate) { prefetchIdx = i; break; }
      }

      const slicedDaily = dailyData.slice(prefetchIdx);
      const rsiValues = calculateRSI(slicedDaily, period);
      if (rsiValues.length === 0) return null;

      let rangeStartIdx = 0;
      for (let i = 0; i < slicedDaily.length; i++) {
        if (slicedDaily[i].date >= cutoffDate) { rangeStartIdx = i; break; }
      }
      if (rangeStartIdx < 1 || rangeStartIdx >= rsiValues.length) return null;

      let totalShares = 0;
      let totalInvested = 0;
      let buyCount = 0;
      const buySignals = [];
      const portfolioValues = [];
      let cooldown = 0;

      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (cooldown > 0) cooldown--;

        if (rsiValues[i] !== null && rsiValues[i - 1] !== null && cooldown === 0) {
          // Buy when RSI first crosses below threshold
          if (rsiValues[i - 1] >= threshold && rsiValues[i] < threshold) {
            totalShares += buyAmount / slicedDaily[i].price;
            totalInvested += buyAmount;
            buyCount++;
            buySignals.push({ date: slicedDaily[i].date, price: slicedDaily[i].price });
            cooldown = 5; // 5-day cooldown between signals
          }
        }

        portfolioValues.push({
          date: slicedDaily[i].date,
          value: totalShares * slicedDaily[i].price,
          invested: totalInvested
        });
      }

      if (buyCount === 0) return { noSignals: true };

      const lastPrice = slicedDaily[slicedDaily.length - 1].price;
      const finalValue = totalShares * lastPrice;

      // Build RSI overlay data
      const chartRsiData = [];
      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (rsiValues[i] !== null) {
          chartRsiData.push({
            date: slicedDaily[i].date,
            price: slicedDaily[i].price,
            rsi: rsiValues[i]
          });
        }
      }

      return {
        totalInvested,
        finalValue,
        profit: finalValue - totalInvested,
        returnPercent: totalInvested > 0 ? ((finalValue - totalInvested) / totalInvested) * 100 : 0,
        totalShares,
        avgCostPerShare: totalInvested / totalShares,
        maxDrawdown: computeMaxDrawdown(portfolioValues),
        portfolioValues,
        investedValues: portfolioValues.map(v => v.invested),
        buyCount,
        buySignals,
        rsiData: chartRsiData,
        isRsi: true
      };
    }

    // Backtest MACD Divergence
    function backtestMACD(dailyData, buyAmount, yearsAgo, fast = 12, slow = 26, signal = 9) {
      if (!dailyData || dailyData.length < slow + signal) return null;

      const now = new Date();
      const cutoffDate = new Date(now);
      cutoffDate.setFullYear(cutoffDate.getFullYear() - yearsAgo);

      const prefetchDays = slow + signal + 50;
      const prefetchDate = new Date(cutoffDate);
      prefetchDate.setDate(prefetchDate.getDate() - prefetchDays);

      let prefetchIdx = 0;
      for (let i = 0; i < dailyData.length; i++) {
        if (dailyData[i].date >= prefetchDate) { prefetchIdx = i; break; }
      }

      const slicedDaily = dailyData.slice(prefetchIdx);
      const macdResult = calculateMACD(slicedDaily, fast, slow, signal);
      if (!macdResult) return null;

      const { macdLine, signalLine } = macdResult;

      let rangeStartIdx = 0;
      for (let i = 0; i < slicedDaily.length; i++) {
        if (slicedDaily[i].date >= cutoffDate) { rangeStartIdx = i; break; }
      }
      if (rangeStartIdx < 1 || rangeStartIdx >= macdLine.length) return null;

      let totalShares = 0;
      let totalInvested = 0;
      let buyCount = 0;
      const buySignals = [];
      const portfolioValues = [];

      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (macdLine[i] !== null && signalLine[i] !== null && macdLine[i - 1] !== null && signalLine[i - 1] !== null) {
          // Bullish crossover: MACD crosses above signal
          if (macdLine[i - 1] <= signalLine[i - 1] && macdLine[i] > signalLine[i]) {
            totalShares += buyAmount / slicedDaily[i].price;
            totalInvested += buyAmount;
            buyCount++;
            buySignals.push({ date: slicedDaily[i].date, price: slicedDaily[i].price });
          }
        }

        portfolioValues.push({
          date: slicedDaily[i].date,
          value: totalShares * slicedDaily[i].price,
          invested: totalInvested
        });
      }

      if (buyCount === 0) return { noSignals: true };

      const lastPrice = slicedDaily[slicedDaily.length - 1].price;
      const finalValue = totalShares * lastPrice;

      // Build MACD overlay data
      const chartMacdData = [];
      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (macdLine[i] !== null && signalLine[i] !== null) {
          chartMacdData.push({
            date: slicedDaily[i].date,
            price: slicedDaily[i].price,
            macd: macdLine[i],
            signal: signalLine[i]
          });
        }
      }

      return {
        totalInvested,
        finalValue,
        profit: finalValue - totalInvested,
        returnPercent: totalInvested > 0 ? ((finalValue - totalInvested) / totalInvested) * 100 : 0,
        totalShares,
        avgCostPerShare: totalInvested / totalShares,
        maxDrawdown: computeMaxDrawdown(portfolioValues),
        portfolioValues,
        investedValues: portfolioValues.map(v => v.invested),
        buyCount,
        buySignals,
        macdData: chartMacdData,
        isMacd: true
      };
    }

    // Run backtest for a single ticker entry
    function backtestSingle(entry, amount) {
      const data = entry.data;
      if (!data || !data.dailyData || data.dailyData.length === 0) return null;

      switch (state.style) {
        case 'dca':
          return backtestDCA(data.dailyData, amount, state.years);
        case 'lump':
          return backtestLumpSum(data.dailyData, amount, state.years);
        case 'ema50':
          return backtestEMA(data.dailyData, amount, state.years, 50);
        case 'ema100':
          return backtestEMA(data.dailyData, amount, state.years, 100);
        case 'ema200':
          return backtestEMA(data.dailyData, amount, state.years, 200);
        case 'emaCrossover':
          return backtestEMACrossover(data.dailyData, amount, state.years);
        case 'rsi':
          return backtestRSI(data.dailyData, amount, state.years);
        case 'macd':
          return backtestMACD(data.dailyData, amount, state.years);
        default:
          return null;
      }
    }

    // Calculate aggregate portfolio results
    function calculate() {
      const portfolio = state.portfolio;
      if (portfolio.length === 0) return null;

      const totalAlloc = getTotalAllocation();
      if (totalAlloc === 0) return null;

      const perTickerResults = [];
      let anyData = false;
      let allNoSignals = true;

      for (const entry of portfolio) {
        const tickerAmount = state.amount * (entry.allocation / totalAlloc);
        const result = backtestSingle(entry, tickerAmount);
        perTickerResults.push({
          symbol: entry.symbol,
          name: entry.name,
          allocation: entry.allocation,
          currentPrice: entry.data ? entry.data.currentPrice : 0,
          priceChange: entry.data ? entry.data.priceChange : 0,
          percentChange: entry.data ? entry.data.percentChange : 0,
          result
        });
        if (result && !result.noSignals) {
          anyData = true;
          allNoSignals = false;
        }
      }

      if (!anyData) {
        if (allNoSignals && perTickerResults.some(p => p.result && p.result.noSignals)) {
          return { noSignals: true, perTickerResults };
        }
        return null;
      }

      // Find shortest common timeline length
      let minLen = Infinity;
      for (const ptr of perTickerResults) {
        if (ptr.result && ptr.result.portfolioValues && !ptr.result.noSignals) {
          minLen = Math.min(minLen, ptr.result.portfolioValues.length);
        }
      }
      if (minLen === Infinity || minLen === 0) return null;

      // Aggregate portfolio values
      const aggregateValues = [];
      let aggregateTotalInvested = 0;
      let aggregateFinalValue = 0;

      for (let i = 0; i < minLen; i++) {
        let sumValue = 0;
        let sumInvested = 0;
        let date = null;
        for (const ptr of perTickerResults) {
          if (ptr.result && ptr.result.portfolioValues && !ptr.result.noSignals) {
            const pv = ptr.result.portfolioValues[i];
            sumValue += pv.value;
            sumInvested += pv.invested;
            if (!date) date = pv.date;
          }
        }
        aggregateValues.push({ date, value: sumValue, invested: sumInvested });
      }

      for (const ptr of perTickerResults) {
        if (ptr.result && !ptr.result.noSignals) {
          aggregateTotalInvested += ptr.result.totalInvested;
          aggregateFinalValue += ptr.result.finalValue;
        }
      }

      const profit = aggregateFinalValue - aggregateTotalInvested;
      const returnPercent = aggregateTotalInvested > 0 ? ((aggregateFinalValue - aggregateTotalInvested) / aggregateTotalInvested) * 100 : 0;

      // Aggregate max drawdown
      const maxDrawdown = computeMaxDrawdown(aggregateValues);

      // For single-ticker portfolios, pass through overlay data
      let overlayData = {};
      if (portfolio.length === 1 && perTickerResults[0].result) {
        const r = perTickerResults[0].result;
        if (r.isEma) {
          overlayData = { emaData: r.emaData, isEma: true, emaPeriod: r.emaPeriod, buySignals: r.buySignals, buyCount: r.buyCount };
        } else if (r.isEmaCrossover) {
          overlayData = { emaData: r.emaData, isEmaCrossover: true, buySignals: r.buySignals, buyCount: r.buyCount };
        } else if (r.isRsi) {
          overlayData = { rsiData: r.rsiData, isRsi: true, buySignals: r.buySignals, buyCount: r.buyCount };
        } else if (r.isMacd) {
          overlayData = { macdData: r.macdData, isMacd: true, buySignals: r.buySignals, buyCount: r.buyCount };
        }
      }

      return {
        totalInvested: aggregateTotalInvested,
        finalValue: aggregateFinalValue,
        profit,
        returnPercent,
        maxDrawdown,
        portfolioValues: aggregateValues,
        perTickerResults,
        ...overlayData
      };
    }

    // --- Portfolio management ---
    function getTotalAllocation() {
      return state.portfolio.reduce((sum, e) => sum + e.allocation, 0);
    }

    function renderPortfolioList() {
      const list = portfolioListEl;
      list.innerHTML = '';

      if (state.portfolio.length === 0) {
        list.innerHTML = '<div class="portfolio-empty">Add a stock to get started</div>';
      }

      state.portfolio.forEach((entry, idx) => {
        const div = document.createElement('div');
        div.className = 'portfolio-entry';
        div.innerHTML = `
          <span class="pe-symbol">${entry.symbol}</span>
          <span class="pe-name">${entry.name}</span>
          <input type="text" class="portfolio-alloc-input" value="${entry.allocation}" data-idx="${idx}" inputmode="numeric">
          <span class="pe-pct-label">%</span>
          <button class="remove-ticker-btn" data-idx="${idx}">&times;</button>
        `;
        list.appendChild(div);
      });

      // Wire allocation inputs
      list.querySelectorAll('.portfolio-alloc-input').forEach(input => {
        input.addEventListener('input', (e) => {
          const idx = parseInt(e.target.dataset.idx);
          const val = parseInt(e.target.value.replace(/[^0-9]/g, '')) || 0;
          state.portfolio[idx].allocation = val;
          updateAllocationBar();
          updateResults();
        });
        input.addEventListener('blur', (e) => {
          const idx = parseInt(e.target.dataset.idx);
          e.target.value = state.portfolio[idx].allocation;
        });
        input.addEventListener('focus', (e) => {
          e.target.select();
        });
      });

      // Wire remove buttons
      list.querySelectorAll('.remove-ticker-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const idx = parseInt(e.target.dataset.idx);
          removeTickerFromPortfolio(idx);
        });
      });

      updateAllocationBar();
    }

    function updateAllocationBar() {
      const total = getTotalAllocation();
      allocationFill.style.width = Math.min(total, 100) + '%';

      if (total === 100) {
        allocationFill.className = 'allocation-fill ok';
        allocationStatus.textContent = `Total: ${total}%`;
        allocationStatus.className = 'allocation-status';
      } else if (total > 100) {
        allocationFill.className = 'allocation-fill over';
        allocationStatus.textContent = `Total: ${total}% (over 100%)`;
        allocationStatus.className = 'allocation-status warn';
      } else {
        allocationFill.className = 'allocation-fill under';
        allocationStatus.textContent = `Total: ${total}%`;
        allocationStatus.className = 'allocation-status';
      }
    }

    async function addTickerToPortfolio(ticker) {
      // Silently ignore duplicates
      if (state.portfolio.some(e => e.symbol === ticker.symbol)) return;

      const remaining = Math.max(0, 100 - getTotalAllocation());
      const allocation = remaining > 0 ? remaining : 10;

      const entry = {
        symbol: ticker.symbol,
        yahoo: ticker.yahoo,
        name: ticker.name,
        allocation,
        data: null
      };

      state.portfolio.push(entry);
      renderPortfolioList();

      // Fetch data
      resultsCard.classList.add('loading');
      entry.data = await fetchStockData(ticker.yahoo);
      resultsCard.classList.remove('loading');
      updateResults();
    }

    function removeTickerFromPortfolio(idx) {
      state.portfolio.splice(idx, 1);
      renderPortfolioList();
      updateResults();
    }

    // Load data for all portfolio tickers
    async function loadPortfolioData() {
      resultsCard.classList.add('loading');
      await Promise.all(
        state.portfolio.map(async (entry) => {
          entry.data = await fetchStockData(entry.yahoo);
        })
      );
      resultsCard.classList.remove('loading');
      updateResults();
    }

    // Update results display
    function updateResults() {
      const results = calculate();

      if (!results || results.noSignals) {
        document.getElementById('total-contributed').textContent = results && results.noSignals ? '$0' : (state.portfolio.length === 0 ? '-' : 'No data');
        document.getElementById('final-value').textContent = results && results.noSignals ? '$0' : (state.portfolio.length === 0 ? '-' : 'No data');
        document.getElementById('max-drawdown').textContent = '-';
        document.getElementById('total-return').textContent = '-';
        document.getElementById('profit-text').innerHTML = results && results.noSignals ? 'No signals in this period' : '';
        drawChart(null);
        updateChartLegend(null);
        renderBreakdown(results ? results.perTickerResults : null);
        return;
      }

      document.getElementById('total-contributed').textContent = formatCurrency(results.totalInvested);
      document.getElementById('final-value').textContent = formatCurrency(results.finalValue);

      const profitSign = results.profit >= 0 ? '+' : '';
      const returnClass = results.returnPercent >= 0 ? 'positive' : 'negative';
      document.getElementById('profit-text').innerHTML = `Profit: ${profitSign}${formatCurrency(results.profit)} <span class="${returnClass}">(${formatPercent(results.returnPercent)})</span>`;

      const drawdownEl = document.getElementById('max-drawdown');
      drawdownEl.textContent = results.maxDrawdown.toFixed(1) + '%';
      drawdownEl.className = 'result-value negative';

      const totalReturnEl = document.getElementById('total-return');
      const annualizedReturn = results.returnPercent / state.years;
      totalReturnEl.textContent = formatPercent(annualizedReturn) + '/yr';
      totalReturnEl.className = `result-value ${annualizedReturn >= 0 ? 'positive' : 'negative'}`;

      updateChartLegend(results);
      drawChart(results);
      renderBreakdown(results.perTickerResults);
    }

    // Render per-ticker breakdown
    function renderBreakdown(perTickerResults) {
      if (!perTickerResults || perTickerResults.length <= 1) {
        breakdownToggle.style.display = 'none';
        breakdownList.classList.remove('open');
        breakdownList.innerHTML = '';
        return;
      }

      breakdownToggle.style.display = '';
      breakdownList.innerHTML = '';

      for (const ptr of perTickerResults) {
        const r = ptr.result;
        const div = document.createElement('div');
        div.className = 'breakdown-entry';

        if (!r || r.noSignals) {
          div.innerHTML = `
            <div class="breakdown-header">
              <span class="bh-ticker">${ptr.symbol}</span>
              <span class="bh-alloc">${ptr.allocation}%</span>
            </div>
            <div class="breakdown-details">
              <span class="bd-label">Status</span>
              <span class="bd-value">${r && r.noSignals ? 'No signals' : 'No data'}</span>
            </div>`;
        } else {
          const sign = ptr.priceChange >= 0 ? '+' : '';
          div.innerHTML = `
            <div class="breakdown-header">
              <span class="bh-ticker">${ptr.symbol}</span>
              <span class="bh-alloc">${ptr.allocation}%</span>
            </div>
            <div class="breakdown-details">
              <span class="bd-label">Current Price</span>
              <span class="bd-value">$${ptr.currentPrice.toFixed(2)} (${sign}${ptr.percentChange.toFixed(2)}%)</span>
              <span class="bd-label">Value</span>
              <span class="bd-value">${formatCurrency(r.finalValue)}</span>
              <span class="bd-label">Invested</span>
              <span class="bd-value">${formatCurrency(r.totalInvested)}</span>
              <span class="bd-label">Shares</span>
              <span class="bd-value">${r.totalShares.toFixed(4)}</span>
              <span class="bd-label">Avg Cost</span>
              <span class="bd-value">$${r.avgCostPerShare.toFixed(2)}</span>
              <span class="bd-label">Max Drawdown</span>
              <span class="bd-value">${r.maxDrawdown.toFixed(1)}%</span>
            </div>`;
        }
        breakdownList.appendChild(div);
      }
    }

    // Update chart legend based on strategy mode
    function updateChartLegend(results) {
      const legend = document.querySelector('.chart-legend');
      const baseLegend = `
        <div class="legend-item">
          <div class="legend-dot typical"></div>
          <span>Portfolio Value</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background: #d4cfc4;"></div>
          <span>Total Invested</span>
        </div>`;

      if (!results || state.portfolio.length !== 1) {
        legend.innerHTML = baseLegend;
        return;
      }

      if (results.isEma) {
        legend.innerHTML = baseLegend + `
          <div class="legend-item">
            <div class="legend-dot" style="background: #8b9dc3;"></div>
            <span>Stock Price</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #c4713b;"></div>
            <span>${results.emaPeriod} EMA</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #5a7a5a;"></div>
            <span>Buy Signal</span>
          </div>`;
      } else if (results.isEmaCrossover) {
        legend.innerHTML = baseLegend + `
          <div class="legend-item">
            <div class="legend-dot" style="background: #8b9dc3;"></div>
            <span>Stock Price</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #c4713b;"></div>
            <span>50 EMA</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #7a5c8a;"></div>
            <span>200 EMA</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #5a7a5a;"></div>
            <span>Buy Signal</span>
          </div>`;
      } else if (results.isRsi) {
        legend.innerHTML = baseLegend + `
          <div class="legend-item">
            <div class="legend-dot" style="background: #8b9dc3;"></div>
            <span>Stock Price</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #c4713b;"></div>
            <span>RSI(14)</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #5a7a5a;"></div>
            <span>Buy Signal</span>
          </div>`;
      } else if (results.isMacd) {
        legend.innerHTML = baseLegend + `
          <div class="legend-item">
            <div class="legend-dot" style="background: #8b9dc3;"></div>
            <span>Stock Price</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #c4713b;"></div>
            <span>MACD</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #7a5c8a;"></div>
            <span>Signal</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #5a7a5a;"></div>
            <span>Buy Signal</span>
          </div>`;
      } else {
        legend.innerHTML = baseLegend;
      }
    }

    // Draw the chart
    function drawChart(results) {
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');

      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const height = rect.height || 200;
      canvas.width = rect.width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);

      const width = rect.width;
      const padding = { top: 20, right: 20, bottom: 30, left: 60 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      ctx.clearRect(0, 0, width, height);

      if (!results || !results.portfolioValues || results.portfolioValues.length === 0) {
        ctx.fillStyle = '#9a8d79';
        ctx.font = '14px "Times New Roman", Times, serif';
        ctx.textAlign = 'center';
        ctx.fillText('No historical data available', width / 2, height / 2);
        return;
      }

      // Sample for performance
      const values = sampleForChart(results.portfolioValues);
      const allValues = values.map(v => v.value).concat(values.map(v => v.invested));
      const maxValue = Math.max(...allValues);
      const minValue = 0;

      const scaleX = (i) => padding.left + (i / (values.length - 1)) * chartWidth;
      const scaleY = (v) => padding.top + chartHeight - ((v - minValue) / (maxValue - minValue)) * chartHeight;

      // Grid lines
      ctx.strokeStyle = '#e5e0d5';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = padding.top + (i / 4) * chartHeight;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      // Y-axis labels
      ctx.fillStyle = '#9a8d79';
      ctx.font = '11px "Times New Roman", Times, serif';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let i = 0; i <= 4; i++) {
        const value = minValue + ((4 - i) / 4) * (maxValue - minValue);
        const y = padding.top + (i / 4) * chartHeight;
        ctx.fillText(formatCurrency(value), padding.left - 8, y);
      }

      // X-axis labels
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const labelCount = Math.min(5, values.length);
      for (let i = 0; i < labelCount; i++) {
        const idx = Math.floor((i / (labelCount - 1)) * (values.length - 1));
        const x = scaleX(idx);
        const date = values[idx].date;
        const label = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
        ctx.fillText(label, x, height - padding.bottom + 8);
      }

      // Invested line (dashed)
      ctx.strokeStyle = '#d4cfc4';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      values.forEach((v, i) => {
        const x = scaleX(i);
        const y = scaleY(v.invested);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      ctx.setLineDash([]);

      // Portfolio value line
      ctx.strokeStyle = '#a08c6d';
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      values.forEach((v, i) => {
        const x = scaleX(i);
        const y = scaleY(v.value);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Fill area between lines
      ctx.beginPath();
      values.forEach((v, i) => {
        const x = scaleX(i);
        const y = scaleY(v.value);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      for (let i = values.length - 1; i >= 0; i--) {
        ctx.lineTo(scaleX(i), scaleY(values[i].invested));
      }
      ctx.closePath();
      ctx.fillStyle = results.returnPercent >= 0 ? 'rgba(90, 122, 90, 0.15)' : 'rgba(139, 90, 90, 0.15)';
      ctx.fill();

      // --- Overlays (single-ticker only) ---
      if (state.portfolio.length !== 1) return;

      // Helper to draw sampled overlay line
      function drawOverlayLine(data, getY, color, dashed) {
        const sampled = sampleForChart(data);
        const oScaleX = (i) => padding.left + (i / (sampled.length - 1)) * chartWidth;

        let oMin = Infinity, oMax = -Infinity;
        for (const d of sampled) {
          const v = getY(d);
          if (v < oMin) oMin = v;
          if (v > oMax) oMax = v;
        }
        const range = oMax - oMin;
        oMin -= range * 0.05;
        oMax += range * 0.05;
        const oScaleY = (v) => padding.top + chartHeight - ((v - oMin) / (oMax - oMin)) * chartHeight;

        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        if (dashed) ctx.setLineDash([6, 4]);
        else ctx.setLineDash([]);
        ctx.beginPath();
        for (let i = 0; i < sampled.length; i++) {
          const x = oScaleX(i);
          const y = oScaleY(getY(sampled[i]));
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        return { oScaleX, oScaleY, sampled, oMin, oMax };
      }

      // Helper for dual-scale overlay (price + indicator on same scale)
      function drawPriceOverlay(data, getPrice, extras) {
        const sampled = sampleForChart(data);
        let pMin = Infinity, pMax = -Infinity;
        for (const d of sampled) {
          const p = getPrice(d);
          if (p < pMin) pMin = p;
          if (p > pMax) pMax = p;
          for (const fn of extras) {
            const v = fn(d);
            if (v < pMin) pMin = v;
            if (v > pMax) pMax = v;
          }
        }
        const range = pMax - pMin;
        pMin -= range * 0.05;
        pMax += range * 0.05;

        const oScaleX = (i) => padding.left + (i / (sampled.length - 1)) * chartWidth;
        const oScaleY = (v) => padding.top + chartHeight - ((v - pMin) / (pMax - pMin)) * chartHeight;

        // Stock price
        ctx.strokeStyle = '#8b9dc3';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        for (let i = 0; i < sampled.length; i++) {
          const x = oScaleX(i);
          const y = oScaleY(getPrice(sampled[i]));
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        return { oScaleX, oScaleY, sampled };
      }

      // EMA Touch overlay
      if (results.isEma && results.emaData && results.emaData.length > 0) {
        const { oScaleX, oScaleY, sampled } = drawPriceOverlay(results.emaData, d => d.price, [d => d.ema]);

        // EMA line (dashed orange)
        ctx.strokeStyle = '#c4713b';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        for (let i = 0; i < sampled.length; i++) {
          const x = oScaleX(i);
          const y = oScaleY(sampled[i].ema);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // EMA Crossover overlay
      if (results.isEmaCrossover && results.emaData && results.emaData.length > 0) {
        const { oScaleX, oScaleY, sampled } = drawPriceOverlay(results.emaData, d => d.price, [d => d.emaShort, d => d.emaLong]);

        // Short EMA (orange)
        ctx.strokeStyle = '#c4713b';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        for (let i = 0; i < sampled.length; i++) {
          const x = oScaleX(i);
          const y = oScaleY(sampled[i].emaShort);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Long EMA (purple, dashed)
        ctx.strokeStyle = '#7a5c8a';
        ctx.beginPath();
        for (let i = 0; i < sampled.length; i++) {
          const x = oScaleX(i);
          const y = oScaleY(sampled[i].emaLong);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // RSI overlay
      if (results.isRsi && results.rsiData && results.rsiData.length > 0) {
        // Price line
        drawPriceOverlay(results.rsiData, d => d.price, []);

        // RSI on its own scale (0-100)
        const sampled = sampleForChart(results.rsiData);
        const oScaleX = (i) => padding.left + (i / (sampled.length - 1)) * chartWidth;
        const oScaleY = (v) => padding.top + chartHeight - ((v - 0) / (100 - 0)) * chartHeight;

        // RSI line
        ctx.strokeStyle = '#c4713b';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        for (let i = 0; i < sampled.length; i++) {
          const x = oScaleX(i);
          const y = oScaleY(sampled[i].rsi);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Threshold line at RSI 30
        ctx.strokeStyle = 'rgba(139, 90, 90, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        const threshY = oScaleY(30);
        ctx.beginPath();
        ctx.moveTo(padding.left, threshY);
        ctx.lineTo(width - padding.right, threshY);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // MACD overlay
      if (results.isMacd && results.macdData && results.macdData.length > 0) {
        // Price line
        drawPriceOverlay(results.macdData, d => d.price, []);

        // MACD and signal on their own scale
        const sampled = sampleForChart(results.macdData);
        let mMin = Infinity, mMax = -Infinity;
        for (const d of sampled) {
          if (d.macd < mMin) mMin = d.macd;
          if (d.macd > mMax) mMax = d.macd;
          if (d.signal < mMin) mMin = d.signal;
          if (d.signal > mMax) mMax = d.signal;
        }
        const range = mMax - mMin;
        mMin -= range * 0.05;
        mMax += range * 0.05;

        const oScaleX = (i) => padding.left + (i / (sampled.length - 1)) * chartWidth;
        const oScaleY = (v) => padding.top + chartHeight - ((v - mMin) / (mMax - mMin)) * chartHeight;

        // MACD line
        ctx.strokeStyle = '#c4713b';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        for (let i = 0; i < sampled.length; i++) {
          const x = oScaleX(i);
          const y = oScaleY(sampled[i].macd);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Signal line (purple, dashed)
        ctx.strokeStyle = '#7a5c8a';
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        for (let i = 0; i < sampled.length; i++) {
          const x = oScaleX(i);
          const y = oScaleY(sampled[i].signal);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // --- Ticker search dropdown ---
    function renderDropdown(filter) {
      const query = filter.toLowerCase();
      const matches = TICKERS.filter(t =>
        t.symbol.toLowerCase().includes(query) ||
        t.name.toLowerCase().includes(query)
      );

      tickerDropdown.innerHTML = '';
      matches.forEach(t => {
        const div = document.createElement('div');
        div.className = 'ticker-option';
        const inPortfolio = state.portfolio.some(e => e.symbol === t.symbol);
        div.innerHTML = `<span class="ticker-symbol">${t.symbol}${inPortfolio ? ' ' : ''}</span><span class="ticker-name">${t.name}</span>`;
        div.addEventListener('mousedown', (e) => {
          e.preventDefault();
          selectTicker(t);
        });
        tickerDropdown.appendChild(div);
      });

      if (matches.length > 0) {
        tickerDropdown.classList.add('open');
        tickerSearch.classList.add('has-focus');
      } else {
        tickerDropdown.classList.remove('open');
        tickerSearch.classList.remove('has-focus');
      }
    }

    function selectTicker(t) {
      pendingTicker = t;
      tickerSearch.value = `${t.symbol} - ${t.name}`;
      tickerDropdown.classList.remove('open');
      tickerSearch.classList.remove('has-focus');
      addTickerBtn.disabled = false;

      // If ticker already in portfolio, disable button
      if (state.portfolio.some(e => e.symbol === t.symbol)) {
        addTickerBtn.disabled = true;
      }
    }

    tickerSearch.addEventListener('focus', () => {
      tickerSearch.value = '';
      pendingTicker = null;
      addTickerBtn.disabled = true;
      renderDropdown('');
    });

    tickerSearch.addEventListener('input', () => {
      pendingTicker = null;
      addTickerBtn.disabled = true;
      renderDropdown(tickerSearch.value);
    });

    tickerSearch.addEventListener('blur', () => {
      tickerDropdown.classList.remove('open');
      tickerSearch.classList.remove('has-focus');
      if (pendingTicker) {
        tickerSearch.value = `${pendingTicker.symbol} - ${pendingTicker.name}`;
      } else {
        tickerSearch.value = '';
      }
    });

    // Handle Enter key in search to add ticker
    tickerSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && pendingTicker && !addTickerBtn.disabled) {
        e.preventDefault();
        addTickerBtn.click();
      }
    });

    // Close dropdown on outside click
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.ticker-search-wrapper')) {
        tickerDropdown.classList.remove('open');
        tickerSearch.classList.remove('has-focus');
      }
    });

    // Add ticker button
    addTickerBtn.addEventListener('click', () => {
      if (!pendingTicker) return;
      addTickerToPortfolio(pendingTicker);
      pendingTicker = null;
      tickerSearch.value = '';
      addTickerBtn.disabled = true;
    });

    // Breakdown toggle
    breakdownToggle.addEventListener('click', () => {
      breakdownToggle.classList.toggle('open');
      breakdownList.classList.toggle('open');
    });

    // --- Strategy dropdown ---
    function renderStrategyDropdown() {
      strategyDropdown.innerHTML = '';
      for (const [key, cfg] of Object.entries(STRATEGIES)) {
        const div = document.createElement('div');
        div.className = 'strategy-option' + (key === state.style ? ' selected' : '');
        div.dataset.value = key;
        div.innerHTML = `<div class="so-name">${cfg.name}</div><div class="so-desc">${cfg.desc}</div>`;
        div.addEventListener('mousedown', (e) => {
          e.preventDefault();
          selectStrategy(key);
        });
        strategyDropdown.appendChild(div);
      }
    }

    function selectStrategy(key) {
      const cfg = STRATEGIES[key];
      state.style = key;
      strategyBtnText.textContent = cfg.name;
      amountLabel.textContent = cfg.amountLabel;
      amountHint.textContent = cfg.amountHint;
      amountInput.value = cfg.defaultAmount.toLocaleString();
      state.amount = cfg.defaultAmount;

      // Close dropdown
      strategyDropdown.classList.remove('open');
      strategySelectBtn.classList.remove('open');

      // Update selected state in dropdown
      strategyDropdown.querySelectorAll('.strategy-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.value === key);
      });

      updateResults();
    }

    strategySelectBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isOpen = strategyDropdown.classList.contains('open');
      if (isOpen) {
        strategyDropdown.classList.remove('open');
        strategySelectBtn.classList.remove('open');
      } else {
        strategyDropdown.classList.add('open');
        strategySelectBtn.classList.add('open');
      }
    });

    // Close strategy dropdown on outside click
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.strategy-select-wrapper')) {
        strategyDropdown.classList.remove('open');
        strategySelectBtn.classList.remove('open');
      }
    });

    renderStrategyDropdown();

    amountInput.addEventListener('input', (e) => {
      const value = e.target.value.replace(/[^0-9]/g, '');
      state.amount = parseInt(value) || 0;
      updateResults();
    });

    amountInput.addEventListener('blur', (e) => {
      if (state.amount > 0) {
        e.target.value = state.amount.toLocaleString();
      }
    });

    amountInput.addEventListener('focus', (e) => {
      e.target.value = state.amount || '';
    });

    yearsSlider.addEventListener('input', (e) => {
      state.years = parseInt(e.target.value);
      yearsDisplay.textContent = state.years;
      updateResults();
    });

    // Handle window resize for chart
    window.addEventListener('resize', () => {
      if (state.mode === 'simulate') updateResults();
    });

    // === MODE SWITCHING ===
    function switchMode(mode) {
      state.mode = mode;
      document.querySelectorAll('.mode-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.mode === mode);
      });
      document.getElementById('simulate-layout').style.display = mode === 'simulate' ? '' : 'none';
      document.getElementById('optimize-layout').style.display = mode === 'optimize' ? '' : 'none';
    }

    document.querySelectorAll('.mode-tab').forEach(tab => {
      tab.addEventListener('click', () => switchMode(tab.dataset.mode));
    });

    // === OPTIMIZE MODE ===
    const optimizeTargetInput = document.getElementById('optimize-target');
    const optimizeYearsSlider = document.getElementById('optimize-years');
    const optimizeYearsDisplay = document.getElementById('optimize-years-display');
    const runOptimizeBtn = document.getElementById('run-optimize-btn');
    const optimizeStatus = document.getElementById('optimize-status');
    const optimizeStatusText = document.getElementById('optimize-status-text');
    const optimizeProgressFill = document.getElementById('optimize-progress-fill');
    const optimizeResultsContainer = document.getElementById('optimize-results-container');

    optimizeTargetInput.addEventListener('input', (e) => {
      state.optimizeTargetReturn = parseFloat(e.target.value) || 0;
    });
    optimizeTargetInput.addEventListener('blur', (e) => {
      e.target.value = state.optimizeTargetReturn;
    });
    optimizeTargetInput.addEventListener('focus', (e) => {
      e.target.select();
    });

    optimizeYearsSlider.addEventListener('input', (e) => {
      state.optimizeYears = parseInt(e.target.value);
      optimizeYearsDisplay.textContent = state.optimizeYears;
    });

    document.querySelectorAll('.complexity-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.complexity-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.optimizeComplexity = parseInt(btn.dataset.complexity);
      });
    });

    function calculateRiskScore(maxDrawdown, volatility) {
      return Math.abs(maxDrawdown) * 0.6 + volatility * 0.4;
    }

    // Time-Weighted Return: chain-links sub-period returns between cash flows
    // This eliminates the bias of when capital is deployed (fair across DCA vs Lump Sum)
    function calculateTWR(portfolioValues) {
      if (!portfolioValues || portfolioValues.length < 2) return 0;
      let twr = 1;
      for (let i = 1; i < portfolioValues.length; i++) {
        const prevVal = portfolioValues[i - 1].value;
        const currVal = portfolioValues[i].value;
        const cashFlow = portfolioValues[i].invested - portfolioValues[i - 1].invested;
        // Sub-period return: growth of existing assets before new cash flow
        const startVal = prevVal + cashFlow;
        if (startVal > 0) {
          twr *= (currVal / startVal);
        }
      }
      return (twr - 1) * 100; // total TWR as percentage
    }

    // Backtest a single ticker with explicit strategy and years (doesn't use state)
    function backtestSingleWithParams(tickerData, amount, strategy, years) {
      if (!tickerData || !tickerData.dailyData || tickerData.dailyData.length === 0) return null;
      switch (strategy) {
        case 'dca': return backtestDCA(tickerData.dailyData, amount, years);
        case 'lump': return backtestLumpSum(tickerData.dailyData, amount, years);
        case 'ema50': return backtestEMA(tickerData.dailyData, amount, years, 50);
        case 'ema100': return backtestEMA(tickerData.dailyData, amount, years, 100);
        case 'ema200': return backtestEMA(tickerData.dailyData, amount, years, 200);
        case 'emaCrossover': return backtestEMACrossover(tickerData.dailyData, amount, years);
        case 'rsi': return backtestRSI(tickerData.dailyData, amount, years);
        case 'macd': return backtestMACD(tickerData.dailyData, amount, years);
        default: return null;
      }
    }

    async function ensureAllTickersLoaded() {
      if (!bundledDataLoaded) {
        if (!bundledDataPromise) bundledDataPromise = loadBundledData();
        await bundledDataPromise;
      }
      if (!dailyDataLoaded) {
        if (!dailyDataPromise) dailyDataPromise = loadDailyData();
        await dailyDataPromise;
      }
      const missing = TICKERS.filter(t => !dataCache[t.yahoo] || !dataCache[t.yahoo].dailyData || dataCache[t.yahoo].dailyData.length === 0);
      if (missing.length > 0) {
        await Promise.all(missing.map(t => fetchStockData(t.yahoo)));
      }
    }

    // Compute drawdown + volatility in one pass from a flat Float64Array
    function computeRiskFromValues(values, len) {
      let peak = 0, maxDD = 0, prevVal = 0;
      let sumRet = 0, sumRetSq = 0, retCount = 0;
      for (let i = 0; i < len; i++) {
        const val = values[i];
        if (val > peak) peak = val;
        if (peak > 0) {
          const dd = (val - peak) / peak;
          if (dd < maxDD) maxDD = dd;
        }
        if (i > 0 && prevVal > 0) {
          const r = (val - prevVal) / prevVal;
          sumRet += r;
          sumRetSq += r * r;
          retCount++;
        }
        prevVal = val;
      }
      const maxDrawdown = maxDD * 100;
      const meanRet = retCount > 0 ? sumRet / retCount : 0;
      const variance = retCount > 0 ? (sumRetSq / retCount) - (meanRet * meanRet) : 0;
      const volatility = Math.sqrt(Math.max(0, variance)) * Math.sqrt(252) * 100;
      return { maxDrawdown, volatility };
    }

    async function runOptimization(targetReturn, years, complexity, progressCallback) {
      await ensureAllTickersLoaded();

      const strategyKeys = Object.keys(STRATEGIES);
      const defaultAmount = 1000;

      // Phase 1: Pre-compute all (ticker, strategy) backtests with amount=1
      // Store as flat Float64Arrays for fast inner-loop access
      progressCallback(0, 1, 'Pre-computing backtests...');
      const btCache = {};
      const validTickers = [];

      for (const t of TICKERS) {
        const tickerData = dataCache[t.yahoo];
        if (!tickerData || !tickerData.dailyData || tickerData.dailyData.length === 0) continue;
        btCache[t.yahoo] = {};
        let hasAnyResult = false;
        for (const stratKey of strategyKeys) {
          const result = backtestSingleWithParams(tickerData, 1, stratKey, years);
          if (result && !result.noSignals && result.portfolioValues && result.portfolioValues.length > 0 && result.totalInvested > 0) {
            const pv = result.portfolioValues;
            const len = pv.length;
            const values = new Float64Array(len);
            const invested = new Float64Array(len);
            for (let i = 0; i < len; i++) {
              values[i] = pv[i].value;
              invested[i] = pv[i].invested;
            }
            const twrPct = calculateTWR(pv);
            btCache[t.yahoo][stratKey] = {
              totalInvested: result.totalInvested,
              finalValue: result.finalValue,
              twrPct,
              values,
              invested,
              len
            };
            hasAnyResult = true;
          }
        }
        if (hasAnyResult) validTickers.push(t);
      }

      if (validTickers.length === 0) {
        progressCallback(1, 1);
        return [];
      }

      await new Promise(resolve => setTimeout(resolve, 0));

      // Maintain a bounded top-10 list sorted by distance to target
      const results = [];
      let worstDist = Infinity; // distance threshold for 10th best result

      function addResult(entry) {
        const dist = Math.abs(entry.annualizedReturn - targetReturn);
        if (results.length >= 10 && dist >= worstDist) return;
        entry._dist = dist;
        results.push(entry);
        results.sort((a, b) => a._dist - b._dist);
        if (results.length > 10) results.length = 10;
        worstDist = results[results.length - 1]._dist;
      }

      const qt = validTickers;

      if (complexity === 1) {
        // Single asset: use cached scalars, compute risk once per (ticker, strategy)
        const total = qt.length * strategyKeys.length;
        let tested = 0;
        for (const t of qt) {
          for (const stratKey of strategyKeys) {
            tested++;
            const c = btCache[t.yahoo] && btCache[t.yahoo][stratKey];
            if (!c) continue;
            const annRet = c.twrPct / years;
            const risk = computeRiskFromValues(c.values, c.len);
            const riskScore = calculateRiskScore(risk.maxDrawdown, risk.volatility);
            addResult({
              strategy: stratKey,
              strategyName: STRATEGIES[stratKey].name,
              allocations: [{ symbol: t.symbol, allocation: 100 }],
              annualizedReturn: annRet,
              maxDrawdown: risk.maxDrawdown,
              volatility: risk.volatility,
              riskScore,
              totalInvested: c.totalInvested * defaultAmount,
              finalValue: c.finalValue * defaultAmount
            });
          }
        }
        progressCallback(total, total);

      } else if (complexity === 2) {
        // 2-asset: batch all 9 allocation splits per (pair, strategy) in one array pass
        const allocSteps = [90, 80, 70, 60, 50, 40, 30, 20, 10];
        const numSplits = allocSteps.length;
        let pairsDone = 0;
        const totalPairs = (qt.length * (qt.length - 1)) / 2;

        for (let i = 0; i < qt.length; i++) {
          for (let j = i + 1; j < qt.length; j++) {
            pairsDone++;

            for (const stratKey of strategyKeys) {
              const cA = btCache[qt[i].yahoo] && btCache[qt[i].yahoo][stratKey];
              const cB = btCache[qt[j].yahoo] && btCache[qt[j].yahoo][stratKey];
              if (!cA || !cB) continue;

              // Quick skip: if no blend of these two can be closer than current top 10
              const retA = cA.twrPct / years, retB = cB.twrPct / years;
              const blendMin = Math.min(retA, retB), blendMax = Math.max(retA, retB);
              const closestPossible = targetReturn < blendMin ? blendMin - targetReturn
                : targetReturn > blendMax ? targetReturn - blendMax : 0;
              if (results.length >= 10 && closestPossible >= worstDist) continue;

              const minLen = Math.min(cA.len, cB.len);
              const vA = cA.values, vB = cB.values;
              const iA = cA.invested, iB = cB.invested;

              // Pre-compute scales  all splits share the same scale factors
              const scalesA = new Float64Array(numSplits);
              const scalesB = new Float64Array(numSplits);
              for (let s = 0; s < numSplits; s++) {
                scalesA[s] = defaultAmount * allocSteps[s] / 100;
                scalesB[s] = defaultAmount * (100 - allocSteps[s]) / 100;
              }

              // Single pass: compute TWR, drawdown, volatility for all splits
              const twrs = new Float64Array(numSplits).fill(1);
              const peaks = new Float64Array(numSplits);
              const maxDDs = new Float64Array(numSplits);
              const prevVals = new Float64Array(numSplits);
              const prevInvs = new Float64Array(numSplits);
              const sumRets = new Float64Array(numSplits);
              const sumRetSqs = new Float64Array(numSplits);
              let retCount = 0;

              for (let k = 0; k < minLen; k++) {
                const va = vA[k], vb = vB[k];
                const ia = iA[k], ib = iB[k];
                for (let s = 0; s < numSplits; s++) {
                  const val = va * scalesA[s] + vb * scalesB[s];
                  const inv = ia * scalesA[s] + ib * scalesB[s];

                  // TWR: chain-link sub-period returns accounting for cash flows
                  if (k > 0) {
                    const cashFlow = inv - prevInvs[s];
                    const startVal = prevVals[s] + cashFlow;
                    if (startVal > 0) twrs[s] *= (val / startVal);
                  }

                  if (val > peaks[s]) peaks[s] = val;
                  if (peaks[s] > 0) {
                    const dd = (val - peaks[s]) / peaks[s];
                    if (dd < maxDDs[s]) maxDDs[s] = dd;
                  }
                  if (k > 0 && prevVals[s] > 0) {
                    const r = (val - prevVals[s]) / prevVals[s];
                    sumRets[s] += r;
                    sumRetSqs[s] += r * r;
                  }
                  prevVals[s] = val;
                  prevInvs[s] = inv;
                }
                if (k > 0) retCount++;
              }

              for (let s = 0; s < numSplits; s++) {
                const annRet = ((twrs[s] - 1) * 100) / years;
                const maxDrawdown = maxDDs[s] * 100;
                const meanRet = retCount > 0 ? sumRets[s] / retCount : 0;
                const variance = retCount > 0 ? (sumRetSqs[s] / retCount) - (meanRet * meanRet) : 0;
                const vol = Math.sqrt(Math.max(0, variance)) * Math.sqrt(252) * 100;
                const riskScore = calculateRiskScore(maxDrawdown, vol);
                addResult({
                  strategy: stratKey,
                  strategyName: STRATEGIES[stratKey].name,
                  allocations: [
                    { symbol: qt[i].symbol, allocation: allocSteps[s] },
                    { symbol: qt[j].symbol, allocation: 100 - allocSteps[s] }
                  ],
                  annualizedReturn: annRet,
                  maxDrawdown,
                  volatility: vol,
                  riskScore,
                  totalInvested: cA.totalInvested * scalesA[s] + cB.totalInvested * scalesB[s],
                  finalValue: cA.finalValue * scalesA[s] + cB.finalValue * scalesB[s]
                });
              }
            }

            if (pairsDone % 10 === 0) {
              progressCallback(pairsDone, totalPairs);
              await new Promise(resolve => setTimeout(resolve, 0));
            }
          }
        }
        progressCallback(totalPairs, totalPairs);

      } else if (complexity === 3) {
        // 3-asset: batch all allocation splits per (triplet, strategy) in one array pass
        const allocSplits = [];
        for (let a = 60; a >= 20; a -= 10) {
          for (let b = Math.min(80 - a, a); b >= 10; b -= 10) {
            const c = 100 - a - b;
            if (c >= 10 && c <= b) allocSplits.push([a, b, c]);
          }
        }
        const numSplits = allocSplits.length;
        let tripletsDone = 0;
        const totalTriplets = qt.length * (qt.length - 1) * (qt.length - 2) / 6;

        for (let i = 0; i < qt.length; i++) {
          for (let j = i + 1; j < qt.length; j++) {
            for (let m = j + 1; m < qt.length; m++) {
              tripletsDone++;

              for (const stratKey of strategyKeys) {
                const cA = btCache[qt[i].yahoo] && btCache[qt[i].yahoo][stratKey];
                const cB = btCache[qt[j].yahoo] && btCache[qt[j].yahoo][stratKey];
                const cC = btCache[qt[m].yahoo] && btCache[qt[m].yahoo][stratKey];
                if (!cA || !cB || !cC) continue;

                // Quick skip: if no blend of these three can be closer than current top 10
                const retA3 = cA.twrPct / years, retB3 = cB.twrPct / years, retC3 = cC.twrPct / years;
                const blendMin3 = Math.min(retA3, retB3, retC3), blendMax3 = Math.max(retA3, retB3, retC3);
                const closestPossible3 = targetReturn < blendMin3 ? blendMin3 - targetReturn
                  : targetReturn > blendMax3 ? targetReturn - blendMax3 : 0;
                if (results.length >= 10 && closestPossible3 >= worstDist) continue;

                const minLen = Math.min(cA.len, cB.len, cC.len);
                const vA = cA.values, vB = cB.values, vC = cC.values;
                const iA = cA.invested, iB = cB.invested, iC = cC.invested;

                const scalesA = new Float64Array(numSplits);
                const scalesB = new Float64Array(numSplits);
                const scalesC = new Float64Array(numSplits);
                for (let s = 0; s < numSplits; s++) {
                  scalesA[s] = defaultAmount * allocSplits[s][0] / 100;
                  scalesB[s] = defaultAmount * allocSplits[s][1] / 100;
                  scalesC[s] = defaultAmount * allocSplits[s][2] / 100;
                }

                const twrs = new Float64Array(numSplits).fill(1);
                const peaks = new Float64Array(numSplits);
                const maxDDs = new Float64Array(numSplits);
                const prevVals = new Float64Array(numSplits);
                const prevInvs = new Float64Array(numSplits);
                const sumRets = new Float64Array(numSplits);
                const sumRetSqs = new Float64Array(numSplits);
                let retCount = 0;

                for (let k = 0; k < minLen; k++) {
                  const va = vA[k], vb = vB[k], vc = vC[k];
                  const ia = iA[k], ib = iB[k], ic = iC[k];
                  for (let s = 0; s < numSplits; s++) {
                    const val = va * scalesA[s] + vb * scalesB[s] + vc * scalesC[s];
                    const inv = ia * scalesA[s] + ib * scalesB[s] + ic * scalesC[s];

                    if (k > 0) {
                      const cashFlow = inv - prevInvs[s];
                      const startVal = prevVals[s] + cashFlow;
                      if (startVal > 0) twrs[s] *= (val / startVal);
                    }

                    if (val > peaks[s]) peaks[s] = val;
                    if (peaks[s] > 0) {
                      const dd = (val - peaks[s]) / peaks[s];
                      if (dd < maxDDs[s]) maxDDs[s] = dd;
                    }
                    if (k > 0 && prevVals[s] > 0) {
                      const r = (val - prevVals[s]) / prevVals[s];
                      sumRets[s] += r;
                      sumRetSqs[s] += r * r;
                    }
                    prevVals[s] = val;
                    prevInvs[s] = inv;
                  }
                  if (k > 0) retCount++;
                }

                for (let s = 0; s < numSplits; s++) {
                  const annRet = ((twrs[s] - 1) * 100) / years;
                  if (annRet < targetReturn) continue;
                  const maxDrawdown = maxDDs[s] * 100;
                  const meanRet = retCount > 0 ? sumRets[s] / retCount : 0;
                  const variance = retCount > 0 ? (sumRetSqs[s] / retCount) - (meanRet * meanRet) : 0;
                  const vol = Math.sqrt(Math.max(0, variance)) * Math.sqrt(252) * 100;
                  const riskScore = calculateRiskScore(maxDrawdown, vol);
                  addResult({
                    strategy: stratKey,
                    strategyName: STRATEGIES[stratKey].name,
                    allocations: [
                      { symbol: qt[i].symbol, allocation: allocSplits[s][0] },
                      { symbol: qt[j].symbol, allocation: allocSplits[s][1] },
                      { symbol: qt[m].symbol, allocation: allocSplits[s][2] }
                    ],
                    annualizedReturn: annRet,
                    maxDrawdown,
                    volatility: vol,
                    riskScore,
                    totalInvested: cA.totalInvested * scalesA[s] + cB.totalInvested * scalesB[s] + cC.totalInvested * scalesC[s],
                    finalValue: cA.finalValue * scalesA[s] + cB.finalValue * scalesB[s] + cC.finalValue * scalesC[s]
                  });
                }
              }

              if (tripletsDone % 10 === 0) {
                progressCallback(tripletsDone, totalTriplets);
                await new Promise(resolve => setTimeout(resolve, 0));
              }
            }
          }
        }
        progressCallback(totalTriplets, totalTriplets);
      }

      // Already sorted by closest match via addResult()
      return results;
    }

    function renderOptimizeResults(results, targetReturn) {
      const container = optimizeResultsContainer;

      if (!results || results.length === 0) {
        container.innerHTML = `<div class="optimize-empty">No valid portfolios found for this period</div>`;
        return;
      }

      container.innerHTML = '';
      results.forEach((r, idx) => {
        const div = document.createElement('div');
        div.className = 'optimize-result-item';

        const returnClass = r.annualizedReturn >= 0 ? 'positive' : 'negative';
        const diff = r.annualizedReturn - targetReturn;
        const diffStr = (diff >= 0 ? '+' : '') + diff.toFixed(1) + '%';
        const diffClass = Math.abs(diff) < 1 ? 'positive' : (Math.abs(diff) < 3 ? '' : 'negative');
        const chips = r.allocations.map(a => `<span class="ori-chip">${a.symbol} ${a.allocation}%</span>`).join('');

        div.innerHTML = `
          <div class="ori-header">
            <div class="ori-rank">${idx + 1}</div>
            <div class="ori-strategy">${r.strategyName}</div>
            <span class="ori-diff ${diffClass}">${diffStr} from target</span>
          </div>
          <div class="ori-metrics">
            <div class="ori-metric">
              <div class="ori-metric-label">Annual Return</div>
              <div class="ori-metric-value ${returnClass}">${formatPercent(r.annualizedReturn)}/yr</div>
            </div>
            <div class="ori-metric">
              <div class="ori-metric-label">Risk Score</div>
              <div class="ori-metric-value">${r.riskScore.toFixed(1)}</div>
            </div>
            <div class="ori-metric">
              <div class="ori-metric-label">Max Drawdown</div>
              <div class="ori-metric-value negative">${r.maxDrawdown.toFixed(1)}%</div>
            </div>
            <div class="ori-metric">
              <div class="ori-metric-label">Volatility</div>
              <div class="ori-metric-value">${r.volatility.toFixed(1)}%</div>
            </div>
          </div>
          <div class="ori-allocations">${chips}</div>
        `;
        container.appendChild(div);
      });
    }

    let optimizeRunning = false;

    runOptimizeBtn.addEventListener('click', async () => {
      if (optimizeRunning) return;
      optimizeRunning = true;
      runOptimizeBtn.disabled = true;
      runOptimizeBtn.textContent = 'Running...';
      optimizeStatus.classList.add('visible');
      optimizeResultsContainer.innerHTML = '<div class="optimize-empty">Searching...</div>';

      try {
        const results = await runOptimization(
          state.optimizeTargetReturn,
          state.optimizeYears,
          state.optimizeComplexity,
          (tested, total, statusMsg) => {
            if (statusMsg) {
              optimizeStatusText.textContent = statusMsg;
              optimizeProgressFill.style.width = '0%';
            } else {
              const pct = Math.round((tested / total) * 100);
              optimizeStatusText.textContent = `Testing portfolio ${tested} of ${total} (${pct}%)`;
              optimizeProgressFill.style.width = pct + '%';
            }
          }
        );
        renderOptimizeResults(results, state.optimizeTargetReturn);
      } catch (e) {
        optimizeResultsContainer.innerHTML = `<div class="optimize-empty">Error: ${e.message}</div>`;
      }

      optimizeRunning = false;
      runOptimizeBtn.disabled = false;
      runOptimizeBtn.textContent = 'Find Best Portfolios';
      optimizeStatus.classList.remove('visible');
      optimizeProgressFill.style.width = '0%';
    });

    // Initial load
    renderPortfolioList();
    loadPortfolioData();
  </script>
</body>
</html>
