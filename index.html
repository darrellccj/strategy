<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Investment Simulator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Times New Roman', Times, Georgia, serif;
      background: #faf8f5;
      color: #3d3929;
      min-height: 100vh;
      padding: 24px 16px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 600;
      color: #5c5340;
      margin-bottom: 32px;
      text-align: center;
    }

    .card {
      background: #ffffff;
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(92, 83, 64, 0.08);
    }

    .input-group {
      margin-bottom: 24px;
    }

    .input-group:last-child {
      margin-bottom: 0;
    }

    label {
      display: block;
      font-size: 0.9rem;
      font-weight: 500;
      color: #6b5f4d;
      margin-bottom: 10px;
    }

    /* Ticker Search */
    .ticker-search-wrapper {
      position: relative;
    }

    .ticker-search {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid #e5e0d5;
      border-radius: 10px;
      font-size: 1.1rem;
      color: #3d3929;
      background: #faf8f5;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .ticker-search:focus {
      outline: none;
      border-color: #a08c6d;
    }

    .ticker-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #ffffff;
      border: 2px solid #e5e0d5;
      border-top: none;
      border-radius: 0 0 10px 10px;
      max-height: 240px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(92, 83, 64, 0.12);
    }

    .ticker-dropdown.open {
      display: block;
    }

    .ticker-option {
      padding: 12px 16px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.15s ease;
    }

    .ticker-option:hover {
      background: #f0ebe2;
    }

    .ticker-option .ticker-symbol {
      font-weight: 600;
      color: #5c5340;
      font-size: 1rem;
    }

    .ticker-option .ticker-name {
      font-size: 0.85rem;
      color: #9a8d79;
    }

    .ticker-search.has-focus {
      border-radius: 10px 10px 0 0;
    }

    /* Contribution Style Toggle */
    .toggle-container {
      display: flex;
      background: #f0ebe2;
      border-radius: 10px;
      padding: 4px;
    }

    .toggle-btn {
      flex: 1;
      padding: 12px 16px;
      border: none;
      background: transparent;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 500;
      color: #6b5f4d;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: inherit;
    }

    .toggle-btn.active {
      background: #ffffff;
      color: #5c5340;
      box-shadow: 0 2px 4px rgba(92, 83, 64, 0.1);
    }

    /* EMA Dropdown (custom styled like ticker search) */
    .ema-select-wrapper {
      flex: 1;
      position: relative;
    }

    .ema-select-btn {
      width: 100%;
      padding: 12px 16px;
      border: none;
      background: transparent;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 500;
      color: #6b5f4d;
      cursor: pointer;
      font-family: inherit;
      text-align: center;
      transition: all 0.2s ease;
    }

    .ema-select-btn.active {
      background: #ffffff;
      color: #5c5340;
      box-shadow: 0 2px 4px rgba(92, 83, 64, 0.1);
    }

    .ema-select-btn.open {
      border-radius: 8px 8px 0 0;
    }

    .ema-select-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #ffffff;
      border: 2px solid #e5e0d5;
      border-top: none;
      border-radius: 0 0 10px 10px;
      overflow: hidden;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(92, 83, 64, 0.12);
    }

    .ema-select-dropdown.open {
      display: block;
    }

    .ema-option {
      padding: 12px 16px;
      cursor: pointer;
      text-align: center;
      font-size: 0.95rem;
      color: #5c5340;
      transition: background 0.15s ease;
    }

    .ema-option:hover {
      background: #f0ebe2;
    }

    .ema-option.selected {
      background: #f0ebe2;
      font-weight: 500;
    }

    /* Amount Input */
    .amount-input-wrapper {
      position: relative;
    }

    .currency-symbol {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      color: #a08c6d;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .amount-input {
      width: 100%;
      padding: 14px 16px 14px 36px;
      border: 2px solid #e5e0d5;
      border-radius: 10px;
      font-size: 1.1rem;
      color: #3d3929;
      background: #faf8f5;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .amount-input:focus {
      outline: none;
      border-color: #a08c6d;
    }

    .amount-hint {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 6px;
    }

    /* Time Slider */
    .slider-container {
      padding: 0 4px;
    }

    .time-slider {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #e5e0d5;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }

    .time-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #a08c6d;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(92, 83, 64, 0.3);
      transition: transform 0.2s ease;
    }

    .time-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .time-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #a08c6d;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(92, 83, 64, 0.3);
    }

    .slider-value {
      text-align: center;
      font-size: 1.5rem;
      font-weight: 600;
      color: #5c5340;
      margin-top: 12px;
    }

    .slider-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 8px;
    }

    /* Results Section */
    .results-card {
      background: linear-gradient(135deg, #f5f0e8 0%, #ebe5d9 100%);
    }

    .results-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 24px;
    }

    .result-item {
      background: #ffffff;
      padding: 16px;
      border-radius: 12px;
    }

    .result-item.full-width {
      grid-column: 1 / -1;
    }

    .result-label {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-bottom: 6px;
    }

    .result-value {
      font-size: 1.4rem;
      font-weight: 600;
      color: #5c5340;
    }

    .result-value.positive {
      color: #5a7a5a;
    }

    .result-value.negative {
      color: #8b5a5a;
    }

    .result-subtext {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 4px;
    }

    /* Chart */
    .chart-container {
      background: #ffffff;
      border-radius: 12px;
      padding: 16px;
    }

    .chart-title {
      font-size: 0.85rem;
      color: #6b5f4d;
      margin-bottom: 12px;
      font-weight: 500;
    }

    canvas {
      width: 100%;
      height: 200px;
    }

    .chart-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 12px;
      font-size: 0.8rem;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .legend-dot.typical { background: #a08c6d; }

    /* Loading state */
    .loading {
      opacity: 0.5;
      pointer-events: none;
    }

    .stock-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: #f0ebe2;
      border-radius: 10px;
      margin-top: 10px;
    }

    .stock-price {
      font-size: 1.2rem;
      font-weight: 600;
      color: #5c5340;
    }

    .stock-change {
      font-size: 0.9rem;
      font-weight: 500;
    }

    .stock-change.positive { color: #5a7a5a; }
    .stock-change.negative { color: #8b5a5a; }

    .data-source {
      font-size: 0.7rem;
      color: #9a8d79;
      text-align: center;
      margin-top: 16px;
    }

    .error-message {
      background: #f8e8e8;
      color: #8b5a5a;
      padding: 12px;
      border-radius: 8px;
      font-size: 0.85rem;
      margin-top: 10px;
    }

    /* Portfolio Builder */
    .portfolio-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 12px;
    }

    .portfolio-entry {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      background: #f0ebe2;
      border-radius: 10px;
    }

    .portfolio-entry .pe-symbol {
      font-weight: 600;
      color: #5c5340;
      font-size: 0.95rem;
      min-width: 50px;
    }

    .portfolio-entry .pe-name {
      flex: 1;
      font-size: 0.8rem;
      color: #9a8d79;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .portfolio-alloc-input {
      width: 58px;
      padding: 6px 4px;
      border: 2px solid #e5e0d5;
      border-radius: 6px;
      font-size: 0.9rem;
      color: #3d3929;
      background: #ffffff;
      font-family: inherit;
      text-align: center;
      transition: border-color 0.2s ease;
    }

    .portfolio-alloc-input:focus {
      outline: none;
      border-color: #a08c6d;
    }

    .pe-pct-label {
      font-size: 0.85rem;
      color: #9a8d79;
    }

    .remove-ticker-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: #9a8d79;
      font-size: 1.2rem;
      cursor: pointer;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .remove-ticker-btn:hover {
      background: #e8d8d0;
      color: #8b5a5a;
    }

    .allocation-bar {
      height: 6px;
      background: #e5e0d5;
      border-radius: 3px;
      margin-bottom: 4px;
      overflow: hidden;
    }

    .allocation-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s ease, background 0.3s ease;
    }

    .allocation-fill.ok {
      background: #5a7a5a;
    }

    .allocation-fill.over {
      background: #8b5a5a;
    }

    .allocation-fill.under {
      background: #a08c6d;
    }

    .allocation-status {
      font-size: 0.75rem;
      color: #9a8d79;
      margin-bottom: 12px;
      text-align: right;
    }

    .allocation-status.warn {
      color: #8b5a5a;
    }

    .add-ticker-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      margin-bottom: 12px;
    }

    .add-ticker-row .ticker-search-wrapper {
      flex: 1;
    }

    .add-ticker-row .ticker-search {
      padding: 10px 12px;
      font-size: 0.95rem;
    }

    .add-ticker-btn {
      padding: 10px 16px;
      border: 2px solid #a08c6d;
      background: #a08c6d;
      color: #ffffff;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .add-ticker-btn:hover {
      background: #8a7760;
      border-color: #8a7760;
    }

    .add-ticker-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .portfolio-empty {
      text-align: center;
      color: #9a8d79;
      font-size: 0.9rem;
      padding: 16px;
    }

    /* Breakdown Section */
    .breakdown-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 10px;
      margin-top: 16px;
      background: #ffffff;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      color: #6b5f4d;
      font-family: inherit;
      width: 100%;
      transition: background 0.15s ease;
    }

    .breakdown-toggle:hover {
      background: #f0ebe2;
    }

    .breakdown-toggle .arrow {
      transition: transform 0.2s ease;
      font-size: 0.7rem;
    }

    .breakdown-toggle.open .arrow {
      transform: rotate(180deg);
    }

    .breakdown-list {
      display: none;
      margin-top: 12px;
      gap: 10px;
      flex-direction: column;
    }

    .breakdown-list.open {
      display: flex;
    }

    .breakdown-entry {
      background: #ffffff;
      border-radius: 10px;
      padding: 14px;
    }

    .breakdown-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .breakdown-header .bh-ticker {
      font-weight: 600;
      color: #5c5340;
      font-size: 0.95rem;
    }

    .breakdown-header .bh-alloc {
      font-size: 0.8rem;
      color: #9a8d79;
    }

    .breakdown-details {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px 16px;
      font-size: 0.8rem;
    }

    .breakdown-details .bd-label {
      color: #9a8d79;
    }

    .breakdown-details .bd-value {
      color: #5c5340;
      font-weight: 500;
      text-align: right;
    }

    /* Small mobile adjustments */
    @media (max-width: 400px) {
      h1 {
        font-size: 1.5rem;
      }

      .results-grid {
        grid-template-columns: 1fr;
      }

      .result-item.full-width {
        grid-column: 1;
      }

      .portfolio-entry .pe-name {
        display: none;
      }
    }

    /* Desktop layout */
    @media (min-width: 768px) {
      body {
        padding: 40px 32px;
      }

      .container {
        max-width: 1200px;
      }

      h1 {
        font-size: 2rem;
        margin-bottom: 40px;
      }

      .main-layout {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
        align-items: start;
      }

      .card {
        padding: 32px;
        margin-bottom: 0;
      }

      .results-card {
        position: sticky;
        top: 40px;
      }

      .input-group {
        margin-bottom: 28px;
      }

      label {
        font-size: 0.95rem;
      }

      .toggle-btn {
        padding: 14px 20px;
        font-size: 1rem;
      }

      .amount-input {
        padding: 16px 16px 16px 40px;
        font-size: 1.2rem;
      }

      .currency-symbol {
        font-size: 1.2rem;
        left: 18px;
      }

      .slider-value {
        font-size: 1.75rem;
      }

      .result-value {
        font-size: 1.6rem;
      }

      .chart-container {
        padding: 20px;
      }

      canvas {
        height: 240px;
      }
    }

    /* Large desktop */
    @media (min-width: 1024px) {
      .main-layout {
        gap: 32px;
      }

      .card {
        padding: 36px;
        border-radius: 20px;
      }

      .result-item {
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Investment Simulator</h1>

    <div class="main-layout">
    <div class="card">
      <div class="input-group">
        <label>Portfolio</label>
        <div class="add-ticker-row">
          <div class="ticker-search-wrapper">
            <input type="text" class="ticker-search" id="ticker-search" placeholder="Add a stock (e.g. AAPL)" autocomplete="off">
            <div class="ticker-dropdown" id="ticker-dropdown"></div>
          </div>
          <button class="add-ticker-btn" id="add-ticker-btn" disabled>+</button>
        </div>
        <div id="portfolio-list" class="portfolio-list"></div>
        <div class="allocation-bar"><div class="allocation-fill ok" id="allocation-fill"></div></div>
        <div class="allocation-status" id="allocation-status">Total: 100%</div>
      </div>

      <div class="input-group">
        <label>Contribution Style</label>
        <div class="toggle-container">
          <button class="toggle-btn active" data-style="dca">Monthly</button>
          <button class="toggle-btn" data-style="lump">Lump Sum</button>
          <div class="ema-select-wrapper" id="ema-wrapper">
            <button class="ema-select-btn" id="ema-select-btn">200 EMA</button>
            <div class="ema-select-dropdown" id="ema-dropdown">
              <div class="ema-option" data-value="ema50">50 EMA</div>
              <div class="ema-option" data-value="ema100">100 EMA</div>
              <div class="ema-option selected" data-value="ema200">200 EMA</div>
            </div>
          </div>
        </div>
      </div>

      <div class="input-group">
        <label id="amount-label">Monthly Amount</label>
        <div class="amount-input-wrapper">
          <span class="currency-symbol">$</span>
          <input type="text" class="amount-input" id="amount" value="500" inputmode="numeric">
        </div>
        <div class="amount-hint" id="amount-hint">Amount you'll invest each month</div>
      </div>

      <div class="input-group">
        <label>If you started investing...</label>
        <div class="slider-container">
          <input type="range" class="time-slider" id="years" min="1" max="10" value="5">
          <div class="slider-value"><span id="years-display">5</span> years ago</div>
          <div class="slider-labels">
            <span>1 year ago</span>
            <span>10 years ago</span>
          </div>
        </div>
      </div>
    </div>

    <div class="card results-card">
      <div class="results-grid">
        <div class="result-item">
          <div class="result-label">Total Contributed</div>
          <div class="result-value" id="total-contributed">$0</div>
        </div>

        <div class="result-item">
          <div class="result-label">Value Today</div>
          <div class="result-value" id="final-value">$0</div>
          <div class="result-subtext" id="profit-text">Profit: $0</div>
        </div>

        <div class="result-item">
          <div class="result-label">Max Drawdown</div>
          <div class="result-value negative" id="max-drawdown">-0%</div>
        </div>

        <div class="result-item">
          <div class="result-label">Total Return</div>
          <div class="result-value" id="total-return">0%</div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">Historical Portfolio Value</div>
        <canvas id="chart"></canvas>
        <div class="chart-legend">
          <div class="legend-item">
            <div class="legend-dot typical"></div>
            <span>Portfolio Value</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #d4cfc4;"></div>
            <span>Total Invested</span>
          </div>
        </div>
        <div class="data-source">Data from Yahoo Finance. Past performance doesn't guarantee future results.</div>
      </div>

      <button class="breakdown-toggle" id="breakdown-toggle" style="display:none;">
        Per-Ticker Breakdown <span class="arrow">&#9660;</span>
      </button>
      <div class="breakdown-list" id="breakdown-list"></div>
    </div>
    </div>
  </div>

  <script>
    // Available tickers
    const TICKERS = [
      { symbol: 'AAPL', yahoo: 'AAPL', name: 'Apple' },
      { symbol: 'MSFT', yahoo: 'MSFT', name: 'Microsoft' },
      { symbol: 'GOOGL', yahoo: 'GOOGL', name: 'Alphabet (Google)' },
      { symbol: 'AMZN', yahoo: 'AMZN', name: 'Amazon' },
      { symbol: 'META', yahoo: 'META', name: 'Meta Platforms' },
      { symbol: 'NVDA', yahoo: 'NVDA', name: 'Nvidia' },
      { symbol: 'TSLA', yahoo: 'TSLA', name: 'Tesla' },
      { symbol: 'GLD', yahoo: 'GLD', name: 'SPDR Gold Trust' },
      { symbol: 'SLV', yahoo: 'SLV', name: 'iShares Silver Trust' },
      { symbol: 'VOO', yahoo: 'VOO', name: 'Vanguard S&P 500 ETF' },
      { symbol: 'SPY', yahoo: 'SPY', name: 'SPDR S&P 500 ETF' },
      { symbol: 'BTC', yahoo: 'BTC-USD', name: 'Bitcoin' },
      { symbol: 'ETH', yahoo: 'ETH-USD', name: 'Ethereum' },
    ];

    // State
    let state = {
      portfolio: [
        { symbol: 'VOO', yahoo: 'VOO', name: 'Vanguard S&P 500 ETF', allocation: 100, data: null }
      ],
      style: 'dca',
      amount: 500,
      years: 5
    };

    // Pending ticker for adding to portfolio
    let pendingTicker = null;

    // Cache for ticker data
    const dataCache = {};

    // Pre-fetched data from data.json (populated on first fetchStockData call)
    let bundledDataLoaded = false;
    let bundledDataPromise = null;

    async function loadBundledData() {
      try {
        const res = await fetch('data.json');
        if (!res.ok) throw new Error('data.json not found');
        const json = await res.json();
        if (json.tickers) {
          for (const [yahooTicker, tickerData] of Object.entries(json.tickers)) {
            const monthlyData = tickerData.monthlyData.map(d => ({
              date: new Date(d.date),
              price: d.price
            }));
            const dailyData = (tickerData.dailyData || []).map(d => ({
              date: new Date(d.date + 'T00:00:00Z'),
              price: d.price
            }));

            dataCache[yahooTicker] = {
              ticker: yahooTicker,
              name: tickerData.name,
              currentPrice: tickerData.currentPrice,
              priceChange: tickerData.priceChange,
              percentChange: tickerData.percentChange,
              currency: tickerData.currency || 'USD',
              monthlyData,
              dailyData
            };
          }
        }
      } catch (e) {
        // data.json not available â€” will fall back to live API
      }
      bundledDataLoaded = true;
    }

    // DOM Elements
    const tickerSearch = document.getElementById('ticker-search');
    const tickerDropdown = document.getElementById('ticker-dropdown');
    const addTickerBtn = document.getElementById('add-ticker-btn');
    const portfolioListEl = document.getElementById('portfolio-list');
    const allocationFill = document.getElementById('allocation-fill');
    const allocationStatus = document.getElementById('allocation-status');
    const styleBtns = document.querySelectorAll('.toggle-btn');
    const amountInput = document.getElementById('amount');
    const amountLabel = document.getElementById('amount-label');
    const amountHint = document.getElementById('amount-hint');
    const yearsSlider = document.getElementById('years');
    const yearsDisplay = document.getElementById('years-display');
    const resultsCard = document.querySelector('.results-card');
    const breakdownToggle = document.getElementById('breakdown-toggle');
    const breakdownList = document.getElementById('breakdown-list');

    // EMA dropdown elements
    const emaSelectBtn = document.getElementById('ema-select-btn');
    const emaDropdown = document.getElementById('ema-dropdown');
    const emaOptions = document.querySelectorAll('.ema-option');
    let selectedEma = 'ema200';

    // Format currency
    function formatCurrency(value) {
      if (value >= 1000000) {
        return '$' + (value / 1000000).toFixed(2) + 'M';
      }
      return '$' + Math.round(value).toLocaleString();
    }

    // Format percentage
    function formatPercent(value) {
      const sign = value >= 0 ? '+' : '';
      return sign + value.toFixed(1) + '%';
    }

    // CORS proxies to try in order
    const CORS_PROXIES = [
      (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
    ];

    // Fetch with CORS proxy fallback
    async function fetchWithProxy(url) {
      for (const proxyFn of CORS_PROXIES) {
        try {
          const proxyUrl = proxyFn(url);
          const response = await fetch(proxyUrl);
          if (response.ok) {
            return await response.json();
          }
        } catch (e) {
          continue;
        }
      }
      throw new Error('All proxies failed');
    }

    // Fetch stock data from Yahoo Finance
    async function fetchStockData(yahooTicker) {
      // Load bundled data on first call
      if (!bundledDataLoaded) {
        if (!bundledDataPromise) bundledDataPromise = loadBundledData();
        await bundledDataPromise;
      }

      // Check cache (may have been populated from data.json)
      if (dataCache[yahooTicker]) {
        return dataCache[yahooTicker];
      }

      const historyUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${yahooTicker}?range=10y&interval=1mo&includePrePost=false`;
      const dailyUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${yahooTicker}?range=2d&interval=1d&includePrePost=false`;
      const dailyHistoryUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${yahooTicker}?range=10y&interval=1d&includePrePost=false`;

      try {
        // Fetch all three in parallel
        const [data, dailyData, dailyHistoryData] = await Promise.all([
          fetchWithProxy(historyUrl),
          fetchWithProxy(dailyUrl).catch(() => null),
          fetchWithProxy(dailyHistoryUrl).catch(() => null)
        ]);

        if (data.chart && data.chart.result && data.chart.result[0]) {
          const result = data.chart.result[0];
          const meta = result.meta;
          const quotes = result.indicators.quote[0];
          const timestamps = result.timestamp;

          // Build monthly price data, one entry per calendar month (latest wins)
          const monthlyMap = new Map();
          for (let i = 0; i < timestamps.length; i++) {
            if (quotes.close[i] !== null) {
              const d = new Date(timestamps[i] * 1000);
              const key = d.getUTCFullYear() + '-' + (d.getUTCMonth() + 1);
              monthlyMap.set(key, { date: d, price: quotes.close[i] });
            }
          }

          const currentPrice = meta.regularMarketPrice;

          // Replace last entry's price with live current price
          const monthlyData = Array.from(monthlyMap.values());
          if (monthlyData.length > 0) {
            monthlyData[monthlyData.length - 1].price = currentPrice;
          }

          // Extract daily change from parallel fetch
          let priceChange = 0;
          let percentChange = 0;
          if (dailyData && dailyData.chart && dailyData.chart.result && dailyData.chart.result[0]) {
            const dailyQuotes = dailyData.chart.result[0].indicators.quote[0];
            const closes = dailyQuotes.close.filter(c => c !== null);
            if (closes.length >= 2) {
              const prevClose = closes[closes.length - 2];
              priceChange = currentPrice - prevClose;
              percentChange = (priceChange / prevClose) * 100;
            }
          }

          // Build daily history data for EMA calculations
          let dailyHistoryArr = [];
          if (dailyHistoryData && dailyHistoryData.chart && dailyHistoryData.chart.result && dailyHistoryData.chart.result[0]) {
            const dResult = dailyHistoryData.chart.result[0];
            const dQuotes = dResult.indicators.quote[0];
            const dTimestamps = dResult.timestamp;
            for (let j = 0; j < dTimestamps.length; j++) {
              if (dQuotes.close[j] !== null) {
                dailyHistoryArr.push({
                  date: new Date(dTimestamps[j] * 1000),
                  price: dQuotes.close[j]
                });
              }
            }
          }

          const tickerData = {
            ticker: yahooTicker,
            name: meta.shortName || meta.symbol,
            currentPrice,
            priceChange,
            percentChange,
            monthlyData,
            dailyData: dailyHistoryArr,
            currency: meta.currency || 'USD'
          };

          // Cache the data
          dataCache[yahooTicker] = tickerData;
          return tickerData;
        }

        throw new Error('Invalid data format');
      } catch (error) {
        console.error('Error fetching stock data:', error);
        return getFallbackData(yahooTicker);
      }
    }

    // Fallback data if API fails
    function getFallbackData(ticker) {
      return {
        ticker,
        name: ticker,
        currentPrice: 0,
        priceChange: 0,
        percentChange: 0,
        monthlyData: [],
        dailyData: [],
        isFallback: true
      };
    }

    // Backtest DCA strategy with actual historical prices
    function backtestDCA(monthlyData, monthlyAmount, yearsAgo) {
      const monthsAgo = yearsAgo * 12;
      const startIndex = Math.max(0, monthlyData.length - monthsAgo);
      const relevantData = monthlyData.slice(startIndex);

      if (relevantData.length < 2) {
        return null;
      }

      let totalShares = 0;
      let totalInvested = 0;
      const portfolioValues = [];
      const investedValues = [];

      for (let i = 0; i < relevantData.length; i++) {
        const price = relevantData[i].price;

        // Buy shares each month
        const sharesBought = monthlyAmount / price;
        totalShares += sharesBought;
        totalInvested += monthlyAmount;

        // Record portfolio value at this point
        const portfolioValue = totalShares * price;
        portfolioValues.push({
          date: relevantData[i].date,
          value: portfolioValue,
          invested: totalInvested
        });
        investedValues.push(totalInvested);
      }

      const currentPrice = relevantData[relevantData.length - 1].price;
      const finalValue = totalShares * currentPrice;
      const profit = finalValue - totalInvested;
      const returnPercent = ((finalValue - totalInvested) / totalInvested) * 100;
      const avgCostPerShare = totalInvested / totalShares;

      // Max drawdown from peak portfolio value
      let peak = 0;
      let maxDrawdown = 0;
      for (const pv of portfolioValues) {
        if (pv.value > peak) peak = pv.value;
        const drawdown = (pv.value - peak) / peak;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
      }

      return {
        totalInvested,
        finalValue,
        profit,
        returnPercent,
        totalShares,
        avgCostPerShare,
        maxDrawdown: maxDrawdown * 100,
        portfolioValues,
        investedValues
      };
    }

    // Backtest lump sum strategy with actual historical prices
    function backtestLumpSum(monthlyData, amount, yearsAgo) {
      const monthsAgo = yearsAgo * 12;
      const startIndex = Math.max(0, monthlyData.length - monthsAgo);
      const relevantData = monthlyData.slice(startIndex);

      if (relevantData.length < 2) {
        return null;
      }

      const buyPrice = relevantData[0].price;
      const shares = amount / buyPrice;
      const portfolioValues = [];
      const investedValues = [];

      for (let i = 0; i < relevantData.length; i++) {
        const price = relevantData[i].price;
        portfolioValues.push({
          date: relevantData[i].date,
          value: shares * price,
          invested: amount
        });
        investedValues.push(amount);
      }

      const currentPrice = relevantData[relevantData.length - 1].price;
      const finalValue = shares * currentPrice;
      const profit = finalValue - amount;
      const returnPercent = ((finalValue - amount) / amount) * 100;

      // Max drawdown from peak portfolio value
      let peak = 0;
      let maxDrawdown = 0;
      for (const pv of portfolioValues) {
        if (pv.value > peak) peak = pv.value;
        const drawdown = (pv.value - peak) / peak;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
      }

      return {
        totalInvested: amount,
        finalValue,
        profit,
        returnPercent,
        totalShares: shares,
        avgCostPerShare: buyPrice,
        maxDrawdown: maxDrawdown * 100,
        portfolioValues,
        investedValues
      };
    }

    // Calculate EMA from daily price data for any period
    function calculateEMA(dailyData, period) {
      if (dailyData.length < period) return [];
      const multiplier = 2 / (period + 1);

      // Seed with SMA of first N days
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += dailyData[i].price;
      }
      const emaValues = new Array(period - 1).fill(null);
      let ema = sum / period;
      emaValues.push(ema);

      for (let i = period; i < dailyData.length; i++) {
        ema = (dailyData[i].price - ema) * multiplier + ema;
        emaValues.push(ema);
      }
      return emaValues;
    }

    // Backtest EMA touch strategy
    function backtestEMA(dailyData, monthlyData, buyAmount, yearsAgo, period = 200) {
      if (!dailyData || dailyData.length < period) return null;

      const now = new Date();
      const cutoffDate = new Date(now);
      cutoffDate.setFullYear(cutoffDate.getFullYear() - yearsAgo);

      // Find start index with prefetch for EMA warmup (period + 100 days buffer)
      const prefetchDays = period + 100;
      const prefetchDate = new Date(cutoffDate);
      prefetchDate.setDate(prefetchDate.getDate() - prefetchDays);

      let prefetchIdx = 0;
      for (let i = 0; i < dailyData.length; i++) {
        if (dailyData[i].date >= prefetchDate) {
          prefetchIdx = i;
          break;
        }
      }

      const slicedDaily = dailyData.slice(prefetchIdx);
      const emaValues = calculateEMA(slicedDaily, period);

      if (emaValues.length === 0) return null;

      // Find the actual start index within slicedDaily for our target period
      let rangeStartIdx = 0;
      for (let i = 0; i < slicedDaily.length; i++) {
        if (slicedDaily[i].date >= cutoffDate) {
          rangeStartIdx = i;
          break;
        }
      }

      // Ensure we have EMA values for the range
      if (rangeStartIdx < 1 || rangeStartIdx >= emaValues.length) return null;

      let totalShares = 0;
      let totalInvested = 0;
      let buyCount = 0;
      const buySignals = [];

      // Detect EMA touches and buy
      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (emaValues[i] === null || emaValues[i - 1] === null) continue;

        const prevPrice = slicedDaily[i - 1].price;
        const prevEMA = emaValues[i - 1];
        const currentPrice = slicedDaily[i].price;
        const currentEMA = emaValues[i];

        // Touch: price crosses down to or through the EMA
        if (prevPrice > prevEMA && currentPrice <= currentEMA) {
          const sharesBought = buyAmount / currentPrice;
          totalShares += sharesBought;
          totalInvested += buyAmount;
          buyCount++;
          buySignals.push({ date: slicedDaily[i].date, price: currentPrice });
        }
      }

      if (buyCount === 0) {
        return { noSignals: true };
      }

      // Sample portfolio values at monthly intervals for chart consistency
      const portfolioValues = [];
      const investedValues = [];

      // Use monthly data within the range for sampling
      const monthCutoff = cutoffDate;
      let runningShares = 0;
      let runningInvested = 0;
      let buySignalIdx = 0;

      // Get monthly dates within range
      const relevantMonthly = monthlyData.filter(m => m.date >= monthCutoff);
      if (relevantMonthly.length === 0) return null;

      for (const month of relevantMonthly) {
        // Count all buy signals up to this month's date
        while (buySignalIdx < buySignals.length && buySignals[buySignalIdx].date <= month.date) {
          runningShares += buyAmount / buySignals[buySignalIdx].price;
          runningInvested += buyAmount;
          buySignalIdx++;
        }

        portfolioValues.push({
          date: month.date,
          value: runningShares * month.price,
          invested: runningInvested
        });
        investedValues.push(runningInvested);
      }

      const lastPrice = relevantMonthly[relevantMonthly.length - 1].price;
      const finalValue = totalShares * lastPrice;
      const profit = finalValue - totalInvested;
      const returnPercent = totalInvested > 0 ? ((finalValue - totalInvested) / totalInvested) * 100 : 0;
      const avgCostPerShare = totalInvested / totalShares;

      // Max drawdown
      let peak = 0;
      let maxDrawdown = 0;
      for (const pv of portfolioValues) {
        if (pv.value > peak) peak = pv.value;
        if (peak > 0) {
          const drawdown = (pv.value - peak) / peak;
          if (drawdown < maxDrawdown) maxDrawdown = drawdown;
        }
      }

      // Build EMA overlay data (daily prices and EMA values within range for chart)
      const chartEmaData = [];
      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (emaValues[i] !== null) {
          chartEmaData.push({
            date: slicedDaily[i].date,
            price: slicedDaily[i].price,
            ema: emaValues[i]
          });
        }
      }

      return {
        totalInvested,
        finalValue,
        profit,
        returnPercent,
        totalShares,
        avgCostPerShare,
        maxDrawdown: maxDrawdown * 100,
        portfolioValues,
        investedValues,
        buyCount,
        buySignals,
        emaData: chartEmaData,
        isEma: true,
        emaPeriod: period
      };
    }

    // Run backtest for a single ticker entry
    function backtestSingle(entry, amount) {
      const data = entry.data;
      if (!data || !data.monthlyData || data.monthlyData.length === 0) return null;

      if (state.style === 'dca') {
        return backtestDCA(data.monthlyData, amount, state.years);
      } else if (state.style === 'lump') {
        return backtestLumpSum(data.monthlyData, amount, state.years);
      } else if (state.style.startsWith('ema')) {
        const period = parseInt(state.style.replace('ema', ''));
        return backtestEMA(data.dailyData, data.monthlyData, amount, state.years, period);
      }
      return null;
    }

    // Calculate aggregate portfolio results
    function calculate() {
      const portfolio = state.portfolio;
      if (portfolio.length === 0) return null;

      const totalAlloc = getTotalAllocation();
      if (totalAlloc === 0) return null;

      const perTickerResults = [];
      let anyData = false;
      let allNoSignals = true;

      for (const entry of portfolio) {
        const tickerAmount = state.amount * (entry.allocation / totalAlloc);
        const result = backtestSingle(entry, tickerAmount);
        perTickerResults.push({
          symbol: entry.symbol,
          name: entry.name,
          allocation: entry.allocation,
          currentPrice: entry.data ? entry.data.currentPrice : 0,
          priceChange: entry.data ? entry.data.priceChange : 0,
          percentChange: entry.data ? entry.data.percentChange : 0,
          result
        });
        if (result && !result.noSignals) {
          anyData = true;
          allNoSignals = false;
        } else if (result && result.noSignals) {
          // at least one has noSignals
        }
      }

      if (!anyData) {
        if (allNoSignals && perTickerResults.some(p => p.result && p.result.noSignals)) {
          return { noSignals: true, perTickerResults };
        }
        return null;
      }

      // Find shortest common timeline length
      let minLen = Infinity;
      for (const ptr of perTickerResults) {
        if (ptr.result && ptr.result.portfolioValues && !ptr.result.noSignals) {
          minLen = Math.min(minLen, ptr.result.portfolioValues.length);
        }
      }
      if (minLen === Infinity || minLen === 0) return null;

      // Aggregate portfolio values
      const aggregateValues = [];
      let aggregateTotalInvested = 0;
      let aggregateFinalValue = 0;

      for (let i = 0; i < minLen; i++) {
        let sumValue = 0;
        let sumInvested = 0;
        let date = null;
        for (const ptr of perTickerResults) {
          if (ptr.result && ptr.result.portfolioValues && !ptr.result.noSignals) {
            const pv = ptr.result.portfolioValues[i];
            sumValue += pv.value;
            sumInvested += pv.invested;
            if (!date) date = pv.date;
          }
        }
        aggregateValues.push({ date, value: sumValue, invested: sumInvested });
      }

      // Sum final totals
      for (const ptr of perTickerResults) {
        if (ptr.result && !ptr.result.noSignals) {
          aggregateTotalInvested += ptr.result.totalInvested;
          aggregateFinalValue += ptr.result.finalValue;
        }
      }

      const profit = aggregateFinalValue - aggregateTotalInvested;
      const returnPercent = aggregateTotalInvested > 0 ? ((aggregateFinalValue - aggregateTotalInvested) / aggregateTotalInvested) * 100 : 0;

      // Compute aggregate max drawdown from combined curve
      let peak = 0;
      let maxDrawdown = 0;
      for (const pv of aggregateValues) {
        if (pv.value > peak) peak = pv.value;
        if (peak > 0) {
          const dd = (pv.value - peak) / peak;
          if (dd < maxDrawdown) maxDrawdown = dd;
        }
      }

      // For single-ticker portfolios, pass through EMA data
      let emaData = null;
      let isEma = false;
      let emaPeriod = null;
      let buySignals = null;
      let buyCount = null;
      if (portfolio.length === 1 && perTickerResults[0].result && perTickerResults[0].result.isEma) {
        const r = perTickerResults[0].result;
        emaData = r.emaData;
        isEma = true;
        emaPeriod = r.emaPeriod;
        buySignals = r.buySignals;
        buyCount = r.buyCount;
      }

      return {
        totalInvested: aggregateTotalInvested,
        finalValue: aggregateFinalValue,
        profit,
        returnPercent,
        maxDrawdown: maxDrawdown * 100,
        portfolioValues: aggregateValues,
        perTickerResults,
        emaData,
        isEma,
        emaPeriod,
        buySignals,
        buyCount
      };
    }

    // --- Portfolio management ---
    function getTotalAllocation() {
      return state.portfolio.reduce((sum, e) => sum + e.allocation, 0);
    }

    function renderPortfolioList() {
      const list = portfolioListEl;
      list.innerHTML = '';

      if (state.portfolio.length === 0) {
        list.innerHTML = '<div class="portfolio-empty">Add a stock to get started</div>';
      }

      state.portfolio.forEach((entry, idx) => {
        const div = document.createElement('div');
        div.className = 'portfolio-entry';
        div.innerHTML = `
          <span class="pe-symbol">${entry.symbol}</span>
          <span class="pe-name">${entry.name}</span>
          <input type="text" class="portfolio-alloc-input" value="${entry.allocation}" data-idx="${idx}" inputmode="numeric">
          <span class="pe-pct-label">%</span>
          <button class="remove-ticker-btn" data-idx="${idx}">&times;</button>
        `;
        list.appendChild(div);
      });

      // Wire allocation inputs
      list.querySelectorAll('.portfolio-alloc-input').forEach(input => {
        input.addEventListener('input', (e) => {
          const idx = parseInt(e.target.dataset.idx);
          const val = parseInt(e.target.value.replace(/[^0-9]/g, '')) || 0;
          state.portfolio[idx].allocation = val;
          updateAllocationBar();
          updateResults();
        });
        input.addEventListener('blur', (e) => {
          const idx = parseInt(e.target.dataset.idx);
          e.target.value = state.portfolio[idx].allocation;
        });
        input.addEventListener('focus', (e) => {
          e.target.select();
        });
      });

      // Wire remove buttons
      list.querySelectorAll('.remove-ticker-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const idx = parseInt(e.target.dataset.idx);
          removeTickerFromPortfolio(idx);
        });
      });

      updateAllocationBar();
    }

    function updateAllocationBar() {
      const total = getTotalAllocation();
      allocationFill.style.width = Math.min(total, 100) + '%';

      if (total === 100) {
        allocationFill.className = 'allocation-fill ok';
        allocationStatus.textContent = `Total: ${total}%`;
        allocationStatus.className = 'allocation-status';
      } else if (total > 100) {
        allocationFill.className = 'allocation-fill over';
        allocationStatus.textContent = `Total: ${total}% (over 100%)`;
        allocationStatus.className = 'allocation-status warn';
      } else {
        allocationFill.className = 'allocation-fill under';
        allocationStatus.textContent = `Total: ${total}%`;
        allocationStatus.className = 'allocation-status';
      }
    }

    async function addTickerToPortfolio(ticker) {
      // Silently ignore duplicates
      if (state.portfolio.some(e => e.symbol === ticker.symbol)) return;

      const remaining = Math.max(0, 100 - getTotalAllocation());
      const allocation = remaining > 0 ? remaining : 10;

      const entry = {
        symbol: ticker.symbol,
        yahoo: ticker.yahoo,
        name: ticker.name,
        allocation,
        data: null
      };

      state.portfolio.push(entry);
      renderPortfolioList();

      // Fetch data
      resultsCard.classList.add('loading');
      entry.data = await fetchStockData(ticker.yahoo);
      resultsCard.classList.remove('loading');
      updateResults();
    }

    function removeTickerFromPortfolio(idx) {
      state.portfolio.splice(idx, 1);
      renderPortfolioList();
      updateResults();
    }

    // Load data for all portfolio tickers
    async function loadPortfolioData() {
      resultsCard.classList.add('loading');
      await Promise.all(
        state.portfolio.map(async (entry) => {
          entry.data = await fetchStockData(entry.yahoo);
        })
      );
      resultsCard.classList.remove('loading');
      updateResults();
    }

    // Update results display
    function updateResults() {
      const results = calculate();

      if (!results || results.noSignals) {
        document.getElementById('total-contributed').textContent = results && results.noSignals ? '$0' : (state.portfolio.length === 0 ? '-' : 'No data');
        document.getElementById('final-value').textContent = results && results.noSignals ? '$0' : (state.portfolio.length === 0 ? '-' : 'No data');
        document.getElementById('max-drawdown').textContent = '-';
        document.getElementById('total-return').textContent = '-';
        document.getElementById('profit-text').innerHTML = results && results.noSignals ? 'No EMA touch signals in this period' : '';
        drawChart(null);
        updateChartLegend(null);
        renderBreakdown(results ? results.perTickerResults : null);
        return;
      }

      // Total contributed
      document.getElementById('total-contributed').textContent = formatCurrency(results.totalInvested);

      // Final value
      document.getElementById('final-value').textContent = formatCurrency(results.finalValue);

      // Profit text with return %
      const profitSign = results.profit >= 0 ? '+' : '';
      const returnClass = results.returnPercent >= 0 ? 'positive' : 'negative';
      document.getElementById('profit-text').innerHTML = `Profit: ${profitSign}${formatCurrency(results.profit)} <span class="${returnClass}">(${formatPercent(results.returnPercent)})</span>`;

      // Max drawdown
      const drawdownEl = document.getElementById('max-drawdown');
      drawdownEl.textContent = results.maxDrawdown.toFixed(1) + '%';
      drawdownEl.className = 'result-value negative';

      // Total return
      const totalReturnEl = document.getElementById('total-return');
      totalReturnEl.textContent = formatPercent(results.returnPercent);
      totalReturnEl.className = `result-value ${results.returnPercent >= 0 ? 'positive' : 'negative'}`;

      // Update chart legend and draw chart
      updateChartLegend(results);
      drawChart(results);
      renderBreakdown(results.perTickerResults);
    }

    // Render per-ticker breakdown
    function renderBreakdown(perTickerResults) {
      if (!perTickerResults || perTickerResults.length <= 1) {
        breakdownToggle.style.display = 'none';
        breakdownList.classList.remove('open');
        breakdownList.innerHTML = '';
        return;
      }

      breakdownToggle.style.display = '';
      breakdownList.innerHTML = '';

      for (const ptr of perTickerResults) {
        const r = ptr.result;
        const div = document.createElement('div');
        div.className = 'breakdown-entry';

        if (!r || r.noSignals) {
          div.innerHTML = `
            <div class="breakdown-header">
              <span class="bh-ticker">${ptr.symbol}</span>
              <span class="bh-alloc">${ptr.allocation}%</span>
            </div>
            <div class="breakdown-details">
              <span class="bd-label">Status</span>
              <span class="bd-value">${r && r.noSignals ? 'No signals' : 'No data'}</span>
            </div>`;
        } else {
          const sign = ptr.priceChange >= 0 ? '+' : '';
          div.innerHTML = `
            <div class="breakdown-header">
              <span class="bh-ticker">${ptr.symbol}</span>
              <span class="bh-alloc">${ptr.allocation}%</span>
            </div>
            <div class="breakdown-details">
              <span class="bd-label">Current Price</span>
              <span class="bd-value">$${ptr.currentPrice.toFixed(2)} (${sign}${ptr.percentChange.toFixed(2)}%)</span>
              <span class="bd-label">Value</span>
              <span class="bd-value">${formatCurrency(r.finalValue)}</span>
              <span class="bd-label">Invested</span>
              <span class="bd-value">${formatCurrency(r.totalInvested)}</span>
              <span class="bd-label">Shares</span>
              <span class="bd-value">${r.totalShares.toFixed(4)}</span>
              <span class="bd-label">Avg Cost</span>
              <span class="bd-value">$${r.avgCostPerShare.toFixed(2)}</span>
              <span class="bd-label">Max Drawdown</span>
              <span class="bd-value">${r.maxDrawdown.toFixed(1)}%</span>
            </div>`;
        }
        breakdownList.appendChild(div);
      }
    }

    // Update chart legend based on strategy mode
    function updateChartLegend(results) {
      const legend = document.querySelector('.chart-legend');
      if (results && results.isEma && state.portfolio.length === 1) {
        const emaPeriod = results.emaPeriod || 200;
        legend.innerHTML = `
          <div class="legend-item">
            <div class="legend-dot typical"></div>
            <span>Portfolio Value</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #d4cfc4;"></div>
            <span>Total Invested</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #8b9dc3;"></div>
            <span>Stock Price</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #c4713b;"></div>
            <span>${emaPeriod} EMA</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #5a7a5a;"></div>
            <span>Buy Signal</span>
          </div>`;
      } else {
        legend.innerHTML = `
          <div class="legend-item">
            <div class="legend-dot typical"></div>
            <span>Portfolio Value</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #d4cfc4;"></div>
            <span>Total Invested</span>
          </div>`;
      }
    }

    // Draw the chart
    function drawChart(results) {
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');

      // Set actual canvas size for crisp rendering
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const height = rect.height || 200;
      canvas.width = rect.width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);

      const width = rect.width;
      const padding = { top: 20, right: 20, bottom: 30, left: 60 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      if (!results || !results.portfolioValues || results.portfolioValues.length === 0) {
        ctx.fillStyle = '#9a8d79';
        ctx.font = '14px "Times New Roman", Times, serif';
        ctx.textAlign = 'center';
        ctx.fillText('No historical data available', width / 2, height / 2);
        return;
      }

      const values = results.portfolioValues;
      const allValues = values.map(v => v.value).concat(values.map(v => v.invested));
      const maxValue = Math.max(...allValues);
      const minValue = 0;

      // Scale functions
      const scaleX = (i) => padding.left + (i / (values.length - 1)) * chartWidth;
      const scaleY = (v) => padding.top + chartHeight - ((v - minValue) / (maxValue - minValue)) * chartHeight;

      // Draw grid lines
      ctx.strokeStyle = '#e5e0d5';
      ctx.lineWidth = 1;

      for (let i = 0; i <= 4; i++) {
        const y = padding.top + (i / 4) * chartHeight;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      // Draw Y-axis labels
      ctx.fillStyle = '#9a8d79';
      ctx.font = '11px "Times New Roman", Times, serif';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';

      for (let i = 0; i <= 4; i++) {
        const value = minValue + ((4 - i) / 4) * (maxValue - minValue);
        const y = padding.top + (i / 4) * chartHeight;
        ctx.fillText(formatCurrency(value), padding.left - 8, y);
      }

      // Draw X-axis labels (dates)
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      const labelCount = Math.min(5, values.length);
      for (let i = 0; i < labelCount; i++) {
        const idx = Math.floor((i / (labelCount - 1)) * (values.length - 1));
        const x = scaleX(idx);
        const date = values[idx].date;
        const label = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
        ctx.fillText(label, x, height - padding.bottom + 8);
      }

      // Draw invested line (dashed)
      ctx.strokeStyle = '#d4cfc4';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();

      values.forEach((v, i) => {
        const x = scaleX(i);
        const y = scaleY(v.invested);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw portfolio value line
      ctx.strokeStyle = '#a08c6d';
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();

      values.forEach((v, i) => {
        const x = scaleX(i);
        const y = scaleY(v.value);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();

      // Fill area between lines
      ctx.beginPath();
      values.forEach((v, i) => {
        const x = scaleX(i);
        const y = scaleY(v.value);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      for (let i = values.length - 1; i >= 0; i--) {
        const x = scaleX(i);
        const y = scaleY(values[i].invested);
        ctx.lineTo(x, y);
      }
      ctx.closePath();

      const isProfit = results.returnPercent >= 0;
      ctx.fillStyle = isProfit ? 'rgba(90, 122, 90, 0.15)' : 'rgba(139, 90, 90, 0.15)';
      ctx.fill();

      // Draw EMA overlay only for single-ticker portfolios
      if (results.isEma && results.emaData && results.emaData.length > 0 && state.portfolio.length === 1) {
        const emaData = results.emaData;

        // Compute secondary Y-scale for price/EMA
        let priceMin = Infinity, priceMax = -Infinity;
        for (const d of emaData) {
          if (d.price < priceMin) priceMin = d.price;
          if (d.price > priceMax) priceMax = d.price;
          if (d.ema < priceMin) priceMin = d.ema;
          if (d.ema > priceMax) priceMax = d.ema;
        }
        // Add 5% padding
        const priceRange = priceMax - priceMin;
        priceMin -= priceRange * 0.05;
        priceMax += priceRange * 0.05;

        const scaleEmaX = (i) => padding.left + (i / (emaData.length - 1)) * chartWidth;
        const scaleEmaY = (v) => padding.top + chartHeight - ((v - priceMin) / (priceMax - priceMin)) * chartHeight;

        // Draw stock price line (muted blue)
        ctx.strokeStyle = '#8b9dc3';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        for (let i = 0; i < emaData.length; i++) {
          const x = scaleEmaX(i);
          const y = scaleEmaY(emaData[i].price);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Draw EMA line (warm orange, dashed)
        ctx.strokeStyle = '#c4713b';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        for (let i = 0; i < emaData.length; i++) {
          const x = scaleEmaX(i);
          const y = scaleEmaY(emaData[i].ema);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // --- Ticker search dropdown ---
    function renderDropdown(filter) {
      const query = filter.toLowerCase();
      const matches = TICKERS.filter(t =>
        t.symbol.toLowerCase().includes(query) ||
        t.name.toLowerCase().includes(query)
      );

      tickerDropdown.innerHTML = '';
      matches.forEach(t => {
        const div = document.createElement('div');
        div.className = 'ticker-option';
        const inPortfolio = state.portfolio.some(e => e.symbol === t.symbol);
        div.innerHTML = `<span class="ticker-symbol">${t.symbol}${inPortfolio ? ' âœ“' : ''}</span><span class="ticker-name">${t.name}</span>`;
        div.addEventListener('mousedown', (e) => {
          e.preventDefault();
          selectTicker(t);
        });
        tickerDropdown.appendChild(div);
      });

      if (matches.length > 0) {
        tickerDropdown.classList.add('open');
        tickerSearch.classList.add('has-focus');
      } else {
        tickerDropdown.classList.remove('open');
        tickerSearch.classList.remove('has-focus');
      }
    }

    function selectTicker(t) {
      pendingTicker = t;
      tickerSearch.value = `${t.symbol} - ${t.name}`;
      tickerDropdown.classList.remove('open');
      tickerSearch.classList.remove('has-focus');
      addTickerBtn.disabled = false;

      // If ticker already in portfolio, disable button
      if (state.portfolio.some(e => e.symbol === t.symbol)) {
        addTickerBtn.disabled = true;
      }
    }

    tickerSearch.addEventListener('focus', () => {
      tickerSearch.value = '';
      pendingTicker = null;
      addTickerBtn.disabled = true;
      renderDropdown('');
    });

    tickerSearch.addEventListener('input', () => {
      pendingTicker = null;
      addTickerBtn.disabled = true;
      renderDropdown(tickerSearch.value);
    });

    tickerSearch.addEventListener('blur', () => {
      tickerDropdown.classList.remove('open');
      tickerSearch.classList.remove('has-focus');
      if (pendingTicker) {
        tickerSearch.value = `${pendingTicker.symbol} - ${pendingTicker.name}`;
      } else {
        tickerSearch.value = '';
      }
    });

    // Handle Enter key in search to add ticker
    tickerSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && pendingTicker && !addTickerBtn.disabled) {
        e.preventDefault();
        addTickerBtn.click();
      }
    });

    // Close dropdown on outside click
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.ticker-search-wrapper')) {
        tickerDropdown.classList.remove('open');
        tickerSearch.classList.remove('has-focus');
      }
    });

    // Add ticker button
    addTickerBtn.addEventListener('click', () => {
      if (!pendingTicker) return;
      addTickerToPortfolio(pendingTicker);
      pendingTicker = null;
      tickerSearch.value = '';
      addTickerBtn.disabled = true;
    });

    // Breakdown toggle
    breakdownToggle.addEventListener('click', () => {
      breakdownToggle.classList.toggle('open');
      breakdownList.classList.toggle('open');
    });

    // --- Other event listeners ---
    styleBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        styleBtns.forEach(b => b.classList.remove('active'));
        emaSelectBtn.classList.remove('active');
        emaDropdown.classList.remove('open');
        emaSelectBtn.classList.remove('open');
        btn.classList.add('active');
        state.style = btn.dataset.style;

        if (state.style === 'dca') {
          amountLabel.textContent = 'Monthly Amount';
          amountHint.textContent = "Amount you'd invest each month";
          amountInput.value = '500';
          state.amount = 500;
        } else if (state.style === 'lump') {
          amountLabel.textContent = 'Initial Investment';
          amountHint.textContent = 'One-time investment amount';
          amountInput.value = '10000';
          state.amount = 10000;
        }

        updateResults();
      });
    });

    // EMA custom dropdown handlers
    emaSelectBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isOpen = emaDropdown.classList.contains('open');

      if (isOpen) {
        emaDropdown.classList.remove('open');
        emaSelectBtn.classList.remove('open');
      } else {
        emaDropdown.classList.add('open');
        emaSelectBtn.classList.add('open');
        // Activate EMA mode when clicking
        if (!emaSelectBtn.classList.contains('active')) {
          styleBtns.forEach(b => b.classList.remove('active'));
          emaSelectBtn.classList.add('active');
          state.style = selectedEma;

          const period = selectedEma.replace('ema', '');
          amountLabel.textContent = 'Buy Amount per Signal';
          amountHint.textContent = `Amount to invest each time price touches ${period} EMA`;
          amountInput.value = '1000';
          state.amount = 1000;
          updateResults();
        }
      }
    });

    emaOptions.forEach(opt => {
      opt.addEventListener('click', (e) => {
        e.stopPropagation();
        const value = opt.dataset.value;
        selectedEma = value;

        // Update selected state
        emaOptions.forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');

        // Update button text
        emaSelectBtn.textContent = opt.textContent;

        // Close dropdown
        emaDropdown.classList.remove('open');
        emaSelectBtn.classList.remove('open');

        // Activate and set state
        styleBtns.forEach(b => b.classList.remove('active'));
        emaSelectBtn.classList.add('active');
        state.style = value;

        const period = value.replace('ema', '');
        amountLabel.textContent = 'Buy Amount per Signal';
        amountHint.textContent = `Amount to invest each time price touches ${period} EMA`;
        amountInput.value = '1000';
        state.amount = 1000;

        updateResults();
      });
    });

    // Close EMA dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.ema-select-wrapper')) {
        emaDropdown.classList.remove('open');
        emaSelectBtn.classList.remove('open');
      }
    });

    amountInput.addEventListener('input', (e) => {
      const value = e.target.value.replace(/[^0-9]/g, '');
      state.amount = parseInt(value) || 0;
      updateResults();
    });

    amountInput.addEventListener('blur', (e) => {
      if (state.amount > 0) {
        e.target.value = state.amount.toLocaleString();
      }
    });

    amountInput.addEventListener('focus', (e) => {
      e.target.value = state.amount || '';
    });

    yearsSlider.addEventListener('input', (e) => {
      state.years = parseInt(e.target.value);
      yearsDisplay.textContent = state.years;
      updateResults();
    });

    // Handle window resize for chart
    window.addEventListener('resize', updateResults);

    // Initial load
    renderPortfolioList();
    loadPortfolioData();
  </script>
</body>
</html>
