<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Investment Simulator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Times New Roman', Times, Georgia, serif;
      background: #faf8f5;
      color: #3d3929;
      min-height: 100vh;
      padding: 24px 16px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 600;
      color: #5c5340;
      margin-bottom: 32px;
      text-align: center;
    }

    .card {
      background: #ffffff;
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(92, 83, 64, 0.08);
    }

    .input-group {
      margin-bottom: 24px;
    }

    .input-group:last-child {
      margin-bottom: 0;
    }

    label {
      display: block;
      font-size: 0.9rem;
      font-weight: 500;
      color: #6b5f4d;
      margin-bottom: 10px;
    }

    /* Ticker Search */
    .ticker-search-wrapper {
      position: relative;
    }

    .ticker-search {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid #e5e0d5;
      border-radius: 10px;
      font-size: 1.1rem;
      color: #3d3929;
      background: #faf8f5;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .ticker-search:focus {
      outline: none;
      border-color: #a08c6d;
    }

    .ticker-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #ffffff;
      border: 2px solid #e5e0d5;
      border-top: none;
      border-radius: 0 0 10px 10px;
      max-height: 240px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(92, 83, 64, 0.12);
    }

    .ticker-dropdown.open {
      display: block;
    }

    .ticker-option {
      padding: 12px 16px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.15s ease;
    }

    .ticker-option:hover {
      background: #f0ebe2;
    }

    .ticker-option .ticker-symbol {
      font-weight: 600;
      color: #5c5340;
      font-size: 1rem;
    }

    .ticker-option .ticker-name {
      font-size: 0.85rem;
      color: #9a8d79;
    }

    .ticker-search.has-focus {
      border-radius: 10px 10px 0 0;
    }

    /* Contribution Style Toggle */
    .toggle-container {
      display: flex;
      background: #f0ebe2;
      border-radius: 10px;
      padding: 4px;
    }

    .toggle-btn {
      flex: 1;
      padding: 12px 16px;
      border: none;
      background: transparent;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 500;
      color: #6b5f4d;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: inherit;
    }

    .toggle-btn.active {
      background: #ffffff;
      color: #5c5340;
      box-shadow: 0 2px 4px rgba(92, 83, 64, 0.1);
    }

    /* Amount Input */
    .amount-input-wrapper {
      position: relative;
    }

    .currency-symbol {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      color: #a08c6d;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .amount-input {
      width: 100%;
      padding: 14px 16px 14px 36px;
      border: 2px solid #e5e0d5;
      border-radius: 10px;
      font-size: 1.1rem;
      color: #3d3929;
      background: #faf8f5;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .amount-input:focus {
      outline: none;
      border-color: #a08c6d;
    }

    .amount-hint {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 6px;
    }

    /* Time Slider */
    .slider-container {
      padding: 0 4px;
    }

    .time-slider {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #e5e0d5;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }

    .time-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #a08c6d;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(92, 83, 64, 0.3);
      transition: transform 0.2s ease;
    }

    .time-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .time-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #a08c6d;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(92, 83, 64, 0.3);
    }

    .slider-value {
      text-align: center;
      font-size: 1.5rem;
      font-weight: 600;
      color: #5c5340;
      margin-top: 12px;
    }

    .slider-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 8px;
    }

    /* Results Section */
    .results-card {
      background: linear-gradient(135deg, #f5f0e8 0%, #ebe5d9 100%);
    }

    .results-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 24px;
    }

    .result-item {
      background: #ffffff;
      padding: 16px;
      border-radius: 12px;
    }

    .result-item.full-width {
      grid-column: 1 / -1;
    }

    .result-label {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-bottom: 6px;
    }

    .result-value {
      font-size: 1.4rem;
      font-weight: 600;
      color: #5c5340;
    }

    .result-value.positive {
      color: #5a7a5a;
    }

    .result-value.negative {
      color: #8b5a5a;
    }

    .result-subtext {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 4px;
    }

    /* Chart */
    .chart-container {
      background: #ffffff;
      border-radius: 12px;
      padding: 16px;
    }

    .chart-title {
      font-size: 0.85rem;
      color: #6b5f4d;
      margin-bottom: 12px;
      font-weight: 500;
    }

    canvas {
      width: 100%;
      height: 200px;
    }

    .chart-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 12px;
      font-size: 0.8rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .legend-dot.typical { background: #a08c6d; }

    /* Settings button */
    .settings-btn {
      position: fixed;
      top: 16px;
      left: 16px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid #e5e0d5;
      background: #ffffff;
      color: #6b5f4d;
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(92, 83, 64, 0.08);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      z-index: 200;
    }

    .settings-btn:hover {
      border-color: #a08c6d;
      box-shadow: 0 2px 12px rgba(92, 83, 64, 0.15);
    }

    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(61, 57, 41, 0.4);
      z-index: 300;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal-content {
      background: #faf8f5;
      border-radius: 16px;
      padding: 32px;
      max-width: 360px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(92, 83, 64, 0.2);
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #5c5340;
      margin-bottom: 24px;
    }

    .modal-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 0;
    }

    .modal-label {
      font-size: 0.95rem;
      color: #3d3929;
    }

    .modal-sublabel {
      font-size: 0.8rem;
      color: #9a8d79;
      margin-top: 2px;
    }

    /* Toggle switch */
    .switch {
      position: relative;
      width: 48px;
      height: 26px;
      flex-shrink: 0;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .switch-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #d4cfc4;
      border-radius: 26px;
      transition: background 0.2s ease;
    }

    .switch-slider::before {
      content: '';
      position: absolute;
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background: #ffffff;
      border-radius: 50%;
      transition: transform 0.2s ease;
    }

    .switch input:checked + .switch-slider {
      background: #a08c6d;
    }

    .switch input:checked + .switch-slider::before {
      transform: translateX(22px);
    }

    .modal-close-btn {
      margin-top: 24px;
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 10px;
      background: #a08c6d;
      color: #ffffff;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      font-family: inherit;
      transition: background 0.2s ease;
    }

    .modal-close-btn:hover {
      background: #8a7660;
    }

    /* Loading state */
    .loading {
      opacity: 0.5;
      pointer-events: none;
    }

    .stock-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: #f0ebe2;
      border-radius: 10px;
      margin-top: 10px;
    }

    .stock-price {
      font-size: 1.2rem;
      font-weight: 600;
      color: #5c5340;
    }

    .stock-change {
      font-size: 0.9rem;
      font-weight: 500;
    }

    .stock-change.positive { color: #5a7a5a; }
    .stock-change.negative { color: #8b5a5a; }

    .data-source {
      font-size: 0.7rem;
      color: #9a8d79;
      text-align: center;
      margin-top: 16px;
    }

    .error-message {
      background: #f8e8e8;
      color: #8b5a5a;
      padding: 12px;
      border-radius: 8px;
      font-size: 0.85rem;
      margin-top: 10px;
    }

    /* Small mobile adjustments */
    @media (max-width: 400px) {
      h1 {
        font-size: 1.5rem;
      }

      .results-grid {
        grid-template-columns: 1fr;
      }

      .result-item.full-width {
        grid-column: 1;
      }
    }

    /* Desktop layout */
    @media (min-width: 768px) {
      body {
        padding: 40px 32px;
      }

      .settings-btn {
        top: 24px;
        left: 24px;
        width: 44px;
        height: 44px;
        font-size: 1.3rem;
      }

      .container {
        max-width: 1200px;
      }

      h1 {
        font-size: 2rem;
        margin-bottom: 40px;
      }

      .main-layout {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
        align-items: start;
      }

      .card {
        padding: 32px;
        margin-bottom: 0;
      }

      .results-card {
        position: sticky;
        top: 40px;
      }

      .input-group {
        margin-bottom: 28px;
      }

      label {
        font-size: 0.95rem;
      }

      .toggle-btn {
        padding: 14px 20px;
        font-size: 1rem;
      }

      .amount-input {
        padding: 16px 16px 16px 40px;
        font-size: 1.2rem;
      }

      .currency-symbol {
        font-size: 1.2rem;
        left: 18px;
      }

      .slider-value {
        font-size: 1.75rem;
      }

      .result-value {
        font-size: 1.6rem;
      }

      .chart-container {
        padding: 20px;
      }

      canvas {
        height: 240px;
      }
    }

    /* Large desktop */
    @media (min-width: 1024px) {
      .main-layout {
        gap: 32px;
      }

      .card {
        padding: 36px;
        border-radius: 20px;
      }

      .result-item {
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <button class="settings-btn" id="settings-btn" title="Settings">&#9881;</button>

  <div class="modal-overlay" id="settings-modal">
    <div class="modal-content">
      <div class="modal-title">Settings</div>
      <div class="modal-row">
        <div>
          <div class="modal-label">Advanced Mode</div>
          <div class="modal-sublabel">Unlock additional strategies</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="advanced-toggle">
          <span class="switch-slider"></span>
        </label>
      </div>
      <button class="modal-close-btn" id="modal-close-btn">Done</button>
    </div>
  </div>

  <div class="container">
    <h1>Investment Simulator</h1>

    <div class="main-layout">
    <div class="card">
      <div class="input-group">
        <label>Search for a Stock</label>
        <div class="ticker-search-wrapper">
          <input type="text" class="ticker-search" id="ticker-search" placeholder="Type to search (e.g. AAPL, BTC)" autocomplete="off">
          <div class="ticker-dropdown" id="ticker-dropdown"></div>
        </div>
        <div class="stock-info" id="stock-info">
          <span class="stock-price" id="stock-price">Loading...</span>
          <span class="stock-change" id="stock-change"></span>
        </div>
      </div>

      <div class="input-group">
        <label>Contribution Style</label>
        <div class="toggle-container">
          <button class="toggle-btn active" data-style="dca">Monthly</button>
          <button class="toggle-btn" data-style="lump">Lump Sum</button>
          <button class="toggle-btn ema-btn" data-style="ema50" style="display:none">50 EMA</button>
          <button class="toggle-btn ema-btn" data-style="ema100" style="display:none">100 EMA</button>
          <button class="toggle-btn ema-btn" data-style="ema200" style="display:none">200 EMA</button>
        </div>
      </div>

      <div class="input-group">
        <label id="amount-label">Monthly Amount</label>
        <div class="amount-input-wrapper">
          <span class="currency-symbol">$</span>
          <input type="text" class="amount-input" id="amount" value="500" inputmode="numeric">
        </div>
        <div class="amount-hint" id="amount-hint">Amount you'll invest each month</div>
      </div>

      <div class="input-group">
        <label>If you started investing...</label>
        <div class="slider-container">
          <input type="range" class="time-slider" id="years" min="1" max="10" value="5">
          <div class="slider-value"><span id="years-display">5</span> years ago</div>
          <div class="slider-labels">
            <span>1 year ago</span>
            <span>10 years ago</span>
          </div>
        </div>
      </div>
    </div>

    <div class="card results-card">
      <div class="results-grid">
        <div class="result-item">
          <div class="result-label">Total Contributed</div>
          <div class="result-value" id="total-contributed">$120,000</div>
        </div>

        <div class="result-item">
          <div class="result-label">Value Today</div>
          <div class="result-value" id="final-value">$270,000</div>
          <div class="result-subtext" id="profit-text">Profit: $150,000</div>
        </div>

        <div class="result-item">
          <div class="result-label">Max Drawdown</div>
          <div class="result-value negative" id="max-drawdown">-0%</div>
        </div>

        <div class="result-item">
          <div class="result-label">Shares Owned</div>
          <div class="result-value" id="shares-owned">0</div>
          <div class="result-subtext" id="avg-cost-text">Avg cost: $0.00/share</div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">Historical Portfolio Value</div>
        <canvas id="chart"></canvas>
        <div class="chart-legend">
          <div class="legend-item">
            <div class="legend-dot typical"></div>
            <span>Portfolio Value</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #d4cfc4;"></div>
            <span>Total Invested</span>
          </div>
        </div>
        <div class="data-source">Data from Yahoo Finance. Past performance doesn't guarantee future results.</div>
      </div>
    </div>
    </div>
  </div>

  <script>
    // Available tickers
    const TICKERS = [
      { symbol: 'AAPL', yahoo: 'AAPL', name: 'Apple' },
      { symbol: 'MSFT', yahoo: 'MSFT', name: 'Microsoft' },
      { symbol: 'GOOGL', yahoo: 'GOOGL', name: 'Alphabet (Google)' },
      { symbol: 'AMZN', yahoo: 'AMZN', name: 'Amazon' },
      { symbol: 'META', yahoo: 'META', name: 'Meta Platforms' },
      { symbol: 'NVDA', yahoo: 'NVDA', name: 'Nvidia' },
      { symbol: 'TSLA', yahoo: 'TSLA', name: 'Tesla' },
      { symbol: 'GLD', yahoo: 'GLD', name: 'SPDR Gold Trust' },
      { symbol: 'SLV', yahoo: 'SLV', name: 'iShares Silver Trust' },
      { symbol: 'VOO', yahoo: 'VOO', name: 'Vanguard S&P 500 ETF' },
      { symbol: 'SPY', yahoo: 'SPY', name: 'SPDR S&P 500 ETF' },
      { symbol: 'BTC', yahoo: 'BTC-USD', name: 'Bitcoin' },
      { symbol: 'ETH', yahoo: 'ETH-USD', name: 'Ethereum' },
    ];

    // State
    let state = {
      ticker: 'VOO',
      yahooTicker: 'VOO',
      style: 'dca',
      amount: 500,
      years: 5,
      tickerData: null
    };

    // Cache for ticker data
    const dataCache = {};

    // Pre-fetched data from data.json (populated on first fetchStockData call)
    let bundledDataLoaded = false;
    let bundledDataPromise = null;

    async function loadBundledData() {
      try {
        const res = await fetch('data.json');
        if (!res.ok) throw new Error('data.json not found');
        const json = await res.json();
        if (json.tickers) {
          for (const [yahooTicker, tickerData] of Object.entries(json.tickers)) {
            const monthlyData = tickerData.monthlyData.map(d => ({
              date: new Date(d.date),
              price: d.price
            }));
            const dailyData = (tickerData.dailyData || []).map(d => ({
              date: new Date(d.date + 'T00:00:00Z'),
              price: d.price
            }));

            dataCache[yahooTicker] = {
              ticker: yahooTicker,
              name: tickerData.name,
              currentPrice: tickerData.currentPrice,
              priceChange: tickerData.priceChange,
              percentChange: tickerData.percentChange,
              currency: tickerData.currency || 'USD',
              monthlyData,
              dailyData
            };
          }
        }
      } catch (e) {
        // data.json not available â€” will fall back to live API
      }
      bundledDataLoaded = true;
    }

    // DOM Elements
    const tickerSearch = document.getElementById('ticker-search');
    const tickerDropdown = document.getElementById('ticker-dropdown');
    const styleBtns = document.querySelectorAll('.toggle-btn');
    const amountInput = document.getElementById('amount');
    const amountLabel = document.getElementById('amount-label');
    const amountHint = document.getElementById('amount-hint');
    const yearsSlider = document.getElementById('years');
    const yearsDisplay = document.getElementById('years-display');
    const resultsCard = document.querySelector('.results-card');
    const stockPriceEl = document.getElementById('stock-price');
    const stockChangeEl = document.getElementById('stock-change');

    // Settings / Advanced mode
    let advancedMode = localStorage.getItem('advancedMode') === 'true';
    const settingsBtn = document.getElementById('settings-btn');
    const settingsModal = document.getElementById('settings-modal');
    const advancedToggle = document.getElementById('advanced-toggle');
    const modalCloseBtn = document.getElementById('modal-close-btn');
    const emaBtns = document.querySelectorAll('.ema-btn');

    advancedToggle.checked = advancedMode;
    updateEmaButtonVisibility();

    function updateEmaButtonVisibility() {
      emaBtns.forEach(btn => btn.style.display = advancedMode ? '' : 'none');
      // If EMA was selected and advanced mode is turned off, revert to DCA
      if (!advancedMode && state.style.startsWith('ema')) {
        state.style = 'dca';
        styleBtns.forEach(b => b.classList.remove('active'));
        document.querySelector('[data-style="dca"]').classList.add('active');
        amountLabel.textContent = 'Monthly Amount';
        amountHint.textContent = "Amount you'd invest each month";
        amountInput.value = '500';
        state.amount = 500;
        updateResults();
      }
    }

    settingsBtn.addEventListener('click', () => {
      settingsModal.classList.add('open');
    });

    modalCloseBtn.addEventListener('click', () => {
      settingsModal.classList.remove('open');
    });

    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.classList.remove('open');
      }
    });

    advancedToggle.addEventListener('change', () => {
      advancedMode = advancedToggle.checked;
      localStorage.setItem('advancedMode', advancedMode);
      updateEmaButtonVisibility();
    });

    // Format currency
    function formatCurrency(value) {
      if (value >= 1000000) {
        return '$' + (value / 1000000).toFixed(2) + 'M';
      }
      return '$' + Math.round(value).toLocaleString();
    }

    // Format percentage
    function formatPercent(value) {
      const sign = value >= 0 ? '+' : '';
      return sign + value.toFixed(1) + '%';
    }

    // CORS proxies to try in order
    const CORS_PROXIES = [
      (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
    ];

    // Fetch with CORS proxy fallback
    async function fetchWithProxy(url) {
      for (const proxyFn of CORS_PROXIES) {
        try {
          const proxyUrl = proxyFn(url);
          const response = await fetch(proxyUrl);
          if (response.ok) {
            return await response.json();
          }
        } catch (e) {
          continue;
        }
      }
      throw new Error('All proxies failed');
    }

    // Fetch stock data from Yahoo Finance
    async function fetchStockData(yahooTicker) {
      // Load bundled data on first call
      if (!bundledDataLoaded) {
        if (!bundledDataPromise) bundledDataPromise = loadBundledData();
        await bundledDataPromise;
      }

      // Check cache (may have been populated from data.json)
      if (dataCache[yahooTicker]) {
        return dataCache[yahooTicker];
      }

      const historyUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${yahooTicker}?range=10y&interval=1mo&includePrePost=false`;
      const dailyUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${yahooTicker}?range=2d&interval=1d&includePrePost=false`;
      const dailyHistoryUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${yahooTicker}?range=10y&interval=1d&includePrePost=false`;

      try {
        // Fetch all three in parallel
        const [data, dailyData, dailyHistoryData] = await Promise.all([
          fetchWithProxy(historyUrl),
          fetchWithProxy(dailyUrl).catch(() => null),
          fetchWithProxy(dailyHistoryUrl).catch(() => null)
        ]);

        if (data.chart && data.chart.result && data.chart.result[0]) {
          const result = data.chart.result[0];
          const meta = result.meta;
          const quotes = result.indicators.quote[0];
          const timestamps = result.timestamp;

          // Build monthly price data, one entry per calendar month (latest wins)
          const monthlyMap = new Map();
          for (let i = 0; i < timestamps.length; i++) {
            if (quotes.close[i] !== null) {
              const d = new Date(timestamps[i] * 1000);
              const key = d.getUTCFullYear() + '-' + (d.getUTCMonth() + 1);
              monthlyMap.set(key, { date: d, price: quotes.close[i] });
            }
          }

          const currentPrice = meta.regularMarketPrice;

          // Replace last entry's price with live current price
          const monthlyData = Array.from(monthlyMap.values());
          if (monthlyData.length > 0) {
            monthlyData[monthlyData.length - 1].price = currentPrice;
          }

          // Extract daily change from parallel fetch
          let priceChange = 0;
          let percentChange = 0;
          if (dailyData && dailyData.chart && dailyData.chart.result && dailyData.chart.result[0]) {
            const dailyQuotes = dailyData.chart.result[0].indicators.quote[0];
            const closes = dailyQuotes.close.filter(c => c !== null);
            if (closes.length >= 2) {
              const prevClose = closes[closes.length - 2];
              priceChange = currentPrice - prevClose;
              percentChange = (priceChange / prevClose) * 100;
            }
          }

          // Build daily history data for EMA calculations
          let dailyHistoryArr = [];
          if (dailyHistoryData && dailyHistoryData.chart && dailyHistoryData.chart.result && dailyHistoryData.chart.result[0]) {
            const dResult = dailyHistoryData.chart.result[0];
            const dQuotes = dResult.indicators.quote[0];
            const dTimestamps = dResult.timestamp;
            for (let j = 0; j < dTimestamps.length; j++) {
              if (dQuotes.close[j] !== null) {
                dailyHistoryArr.push({
                  date: new Date(dTimestamps[j] * 1000),
                  price: dQuotes.close[j]
                });
              }
            }
          }

          const tickerData = {
            ticker: yahooTicker,
            name: meta.shortName || meta.symbol,
            currentPrice,
            priceChange,
            percentChange,
            monthlyData,
            dailyData: dailyHistoryArr,
            currency: meta.currency || 'USD'
          };

          // Cache the data
          dataCache[yahooTicker] = tickerData;
          return tickerData;
        }

        throw new Error('Invalid data format');
      } catch (error) {
        console.error('Error fetching stock data:', error);
        return getFallbackData(yahooTicker);
      }
    }

    // Fallback data if API fails
    function getFallbackData(ticker) {
      return {
        ticker,
        name: ticker,
        currentPrice: 0,
        priceChange: 0,
        percentChange: 0,
        monthlyData: [],
        dailyData: [],
        isFallback: true
      };
    }

    // Backtest DCA strategy with actual historical prices
    function backtestDCA(monthlyData, monthlyAmount, yearsAgo) {
      const monthsAgo = yearsAgo * 12;
      const startIndex = Math.max(0, monthlyData.length - monthsAgo);
      const relevantData = monthlyData.slice(startIndex);

      if (relevantData.length < 2) {
        return null;
      }

      let totalShares = 0;
      let totalInvested = 0;
      const portfolioValues = [];
      const investedValues = [];

      for (let i = 0; i < relevantData.length; i++) {
        const price = relevantData[i].price;

        // Buy shares each month
        const sharesBought = monthlyAmount / price;
        totalShares += sharesBought;
        totalInvested += monthlyAmount;

        // Record portfolio value at this point
        const portfolioValue = totalShares * price;
        portfolioValues.push({
          date: relevantData[i].date,
          value: portfolioValue,
          invested: totalInvested
        });
        investedValues.push(totalInvested);
      }

      const currentPrice = relevantData[relevantData.length - 1].price;
      const finalValue = totalShares * currentPrice;
      const profit = finalValue - totalInvested;
      const returnPercent = ((finalValue - totalInvested) / totalInvested) * 100;
      const avgCostPerShare = totalInvested / totalShares;

      // Max drawdown from peak portfolio value
      let peak = 0;
      let maxDrawdown = 0;
      for (const pv of portfolioValues) {
        if (pv.value > peak) peak = pv.value;
        const drawdown = (pv.value - peak) / peak;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
      }

      return {
        totalInvested,
        finalValue,
        profit,
        returnPercent,
        totalShares,
        avgCostPerShare,
        maxDrawdown: maxDrawdown * 100,
        portfolioValues,
        investedValues
      };
    }

    // Backtest lump sum strategy with actual historical prices
    function backtestLumpSum(monthlyData, amount, yearsAgo) {
      const monthsAgo = yearsAgo * 12;
      const startIndex = Math.max(0, monthlyData.length - monthsAgo);
      const relevantData = monthlyData.slice(startIndex);

      if (relevantData.length < 2) {
        return null;
      }

      const buyPrice = relevantData[0].price;
      const shares = amount / buyPrice;
      const portfolioValues = [];
      const investedValues = [];

      for (let i = 0; i < relevantData.length; i++) {
        const price = relevantData[i].price;
        portfolioValues.push({
          date: relevantData[i].date,
          value: shares * price,
          invested: amount
        });
        investedValues.push(amount);
      }

      const currentPrice = relevantData[relevantData.length - 1].price;
      const finalValue = shares * currentPrice;
      const profit = finalValue - amount;
      const returnPercent = ((finalValue - amount) / amount) * 100;

      // Max drawdown from peak portfolio value
      let peak = 0;
      let maxDrawdown = 0;
      for (const pv of portfolioValues) {
        if (pv.value > peak) peak = pv.value;
        const drawdown = (pv.value - peak) / peak;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
      }

      return {
        totalInvested: amount,
        finalValue,
        profit,
        returnPercent,
        totalShares: shares,
        avgCostPerShare: buyPrice,
        maxDrawdown: maxDrawdown * 100,
        portfolioValues,
        investedValues
      };
    }

    // Calculate EMA from daily price data for any period
    function calculateEMA(dailyData, period) {
      if (dailyData.length < period) return [];
      const multiplier = 2 / (period + 1);

      // Seed with SMA of first N days
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += dailyData[i].price;
      }
      const emaValues = new Array(period - 1).fill(null);
      let ema = sum / period;
      emaValues.push(ema);

      for (let i = period; i < dailyData.length; i++) {
        ema = (dailyData[i].price - ema) * multiplier + ema;
        emaValues.push(ema);
      }
      return emaValues;
    }

    // Backtest EMA touch strategy
    function backtestEMA(dailyData, monthlyData, buyAmount, yearsAgo, period = 200) {
      if (!dailyData || dailyData.length < period) return null;

      const now = new Date();
      const cutoffDate = new Date(now);
      cutoffDate.setFullYear(cutoffDate.getFullYear() - yearsAgo);

      // Find start index with prefetch for EMA warmup (period + 100 days buffer)
      const prefetchDays = period + 100;
      const prefetchDate = new Date(cutoffDate);
      prefetchDate.setDate(prefetchDate.getDate() - prefetchDays);

      let prefetchIdx = 0;
      for (let i = 0; i < dailyData.length; i++) {
        if (dailyData[i].date >= prefetchDate) {
          prefetchIdx = i;
          break;
        }
      }

      const slicedDaily = dailyData.slice(prefetchIdx);
      const emaValues = calculateEMA(slicedDaily, period);

      if (emaValues.length === 0) return null;

      // Find the actual start index within slicedDaily for our target period
      let rangeStartIdx = 0;
      for (let i = 0; i < slicedDaily.length; i++) {
        if (slicedDaily[i].date >= cutoffDate) {
          rangeStartIdx = i;
          break;
        }
      }

      // Ensure we have EMA values for the range
      if (rangeStartIdx < 1 || rangeStartIdx >= emaValues.length) return null;

      let totalShares = 0;
      let totalInvested = 0;
      let buyCount = 0;
      const buySignals = [];

      // Detect EMA touches and buy
      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (emaValues[i] === null || emaValues[i - 1] === null) continue;

        const prevPrice = slicedDaily[i - 1].price;
        const prevEMA = emaValues[i - 1];
        const currentPrice = slicedDaily[i].price;
        const currentEMA = emaValues[i];

        // Touch: price crosses down to or through the EMA
        if (prevPrice > prevEMA && currentPrice <= currentEMA) {
          const sharesBought = buyAmount / currentPrice;
          totalShares += sharesBought;
          totalInvested += buyAmount;
          buyCount++;
          buySignals.push({ date: slicedDaily[i].date, price: currentPrice });
        }
      }

      if (buyCount === 0) {
        return { noSignals: true };
      }

      // Sample portfolio values at monthly intervals for chart consistency
      const portfolioValues = [];
      const investedValues = [];

      // Use monthly data within the range for sampling
      const monthCutoff = cutoffDate;
      let runningShares = 0;
      let runningInvested = 0;
      let buySignalIdx = 0;

      // Get monthly dates within range
      const relevantMonthly = monthlyData.filter(m => m.date >= monthCutoff);
      if (relevantMonthly.length === 0) return null;

      for (const month of relevantMonthly) {
        // Count all buy signals up to this month's date
        while (buySignalIdx < buySignals.length && buySignals[buySignalIdx].date <= month.date) {
          runningShares += buyAmount / buySignals[buySignalIdx].price;
          runningInvested += buyAmount;
          buySignalIdx++;
        }

        portfolioValues.push({
          date: month.date,
          value: runningShares * month.price,
          invested: runningInvested
        });
        investedValues.push(runningInvested);
      }

      const lastPrice = relevantMonthly[relevantMonthly.length - 1].price;
      const finalValue = totalShares * lastPrice;
      const profit = finalValue - totalInvested;
      const returnPercent = totalInvested > 0 ? ((finalValue - totalInvested) / totalInvested) * 100 : 0;
      const avgCostPerShare = totalInvested / totalShares;

      // Max drawdown
      let peak = 0;
      let maxDrawdown = 0;
      for (const pv of portfolioValues) {
        if (pv.value > peak) peak = pv.value;
        if (peak > 0) {
          const drawdown = (pv.value - peak) / peak;
          if (drawdown < maxDrawdown) maxDrawdown = drawdown;
        }
      }

      // Build EMA overlay data (daily prices and EMA values within range for chart)
      const chartEmaData = [];
      for (let i = rangeStartIdx; i < slicedDaily.length; i++) {
        if (emaValues[i] !== null) {
          chartEmaData.push({
            date: slicedDaily[i].date,
            price: slicedDaily[i].price,
            ema: emaValues[i]
          });
        }
      }

      return {
        totalInvested,
        finalValue,
        profit,
        returnPercent,
        totalShares,
        avgCostPerShare,
        maxDrawdown: maxDrawdown * 100,
        portfolioValues,
        investedValues,
        buyCount,
        buySignals,
        emaData: chartEmaData,
        isEma: true,
        emaPeriod: period
      };
    }

    // Calculate backtest results
    function calculate() {
      if (!state.tickerData || !state.tickerData.monthlyData || state.tickerData.monthlyData.length === 0) {
        return null;
      }

      if (state.style === 'dca') {
        return backtestDCA(state.tickerData.monthlyData, state.amount, state.years);
      } else if (state.style === 'lump') {
        return backtestLumpSum(state.tickerData.monthlyData, state.amount, state.years);
      } else if (state.style.startsWith('ema')) {
        const period = parseInt(state.style.replace('ema', ''));
        return backtestEMA(state.tickerData.dailyData, state.tickerData.monthlyData, state.amount, state.years, period);
      }
      return null;
    }

    // Update stock info display
    function updateStockInfo() {
      if (!state.tickerData) return;

      const data = state.tickerData;

      if (data.isFallback) {
        stockPriceEl.textContent = 'No data';
        stockChangeEl.textContent = '(could not load)';
        stockChangeEl.className = 'stock-change';
      } else {
        stockPriceEl.textContent = `$${data.currentPrice.toFixed(2)}`;
        const sign = data.priceChange >= 0 ? '+' : '';
        stockChangeEl.textContent = `${sign}$${data.priceChange.toFixed(2)} (${sign}${data.percentChange.toFixed(2)}%)`;
        stockChangeEl.className = `stock-change ${data.priceChange >= 0 ? 'positive' : 'negative'}`;
      }
    }

    // Update results display
    function updateResults() {
      const results = calculate();
      if (!results || results.noSignals) {
        document.getElementById('total-contributed').textContent = results && results.noSignals ? '$0' : 'No data';
        document.getElementById('final-value').textContent = results && results.noSignals ? '$0' : 'No data';
        document.getElementById('max-drawdown').textContent = '-';
        document.getElementById('shares-owned').textContent = '-';
        document.getElementById('profit-text').innerHTML = results && results.noSignals ? 'No 200 EMA touch signals in this period' : '';
        document.getElementById('avg-cost-text').textContent = '';
        drawChart(null);
        updateChartLegend(null);
        return;
      }

      // Total contributed
      document.getElementById('total-contributed').textContent = formatCurrency(results.totalInvested);

      // Final value
      document.getElementById('final-value').textContent = formatCurrency(results.finalValue);

      // Profit text with return %
      const profitSign = results.profit >= 0 ? '+' : '';
      const returnClass = results.returnPercent >= 0 ? 'positive' : 'negative';
      document.getElementById('profit-text').innerHTML = `Profit: ${profitSign}${formatCurrency(results.profit)} <span class="${returnClass}">(${formatPercent(results.returnPercent)})</span>`;

      // Max drawdown
      const drawdownEl = document.getElementById('max-drawdown');
      drawdownEl.textContent = results.maxDrawdown.toFixed(1) + '%';
      drawdownEl.className = 'result-value negative';

      // Shares owned
      document.getElementById('shares-owned').textContent = results.totalShares.toFixed(4);
      const avgCostText = `Avg cost: $${results.avgCostPerShare.toFixed(2)}/share`;
      document.getElementById('avg-cost-text').textContent = results.isEma
        ? `${avgCostText} (${results.buyCount} buys)`
        : avgCostText;

      // Update chart legend and draw chart
      updateChartLegend(results);
      drawChart(results);
    }

    // Update chart legend based on strategy mode
    function updateChartLegend(results) {
      const legend = document.querySelector('.chart-legend');
      if (results && results.isEma) {
        const emaPeriod = results.emaPeriod || 200;
        legend.innerHTML = `
          <div class="legend-item">
            <div class="legend-dot typical"></div>
            <span>Portfolio Value</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #d4cfc4;"></div>
            <span>Total Invested</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #8b9dc3;"></div>
            <span>Stock Price</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #c4713b;"></div>
            <span>${emaPeriod} EMA</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #5a7a5a;"></div>
            <span>Buy Signal</span>
          </div>`;
      } else {
        legend.innerHTML = `
          <div class="legend-item">
            <div class="legend-dot typical"></div>
            <span>Portfolio Value</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: #d4cfc4;"></div>
            <span>Total Invested</span>
          </div>`;
      }
    }

    // Draw the chart
    function drawChart(results) {
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');

      // Set actual canvas size for crisp rendering
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const height = rect.height || 200;
      canvas.width = rect.width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);

      const width = rect.width;
      const padding = { top: 20, right: 20, bottom: 30, left: 60 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      if (!results || !results.portfolioValues || results.portfolioValues.length === 0) {
        ctx.fillStyle = '#9a8d79';
        ctx.font = '14px "Times New Roman", Times, serif';
        ctx.textAlign = 'center';
        ctx.fillText('No historical data available', width / 2, height / 2);
        return;
      }

      const values = results.portfolioValues;
      const allValues = values.map(v => v.value).concat(values.map(v => v.invested));
      const maxValue = Math.max(...allValues);
      const minValue = 0;

      // Scale functions
      const scaleX = (i) => padding.left + (i / (values.length - 1)) * chartWidth;
      const scaleY = (v) => padding.top + chartHeight - ((v - minValue) / (maxValue - minValue)) * chartHeight;

      // Draw grid lines
      ctx.strokeStyle = '#e5e0d5';
      ctx.lineWidth = 1;

      for (let i = 0; i <= 4; i++) {
        const y = padding.top + (i / 4) * chartHeight;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      // Draw Y-axis labels
      ctx.fillStyle = '#9a8d79';
      ctx.font = '11px "Times New Roman", Times, serif';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';

      for (let i = 0; i <= 4; i++) {
        const value = minValue + ((4 - i) / 4) * (maxValue - minValue);
        const y = padding.top + (i / 4) * chartHeight;
        ctx.fillText(formatCurrency(value), padding.left - 8, y);
      }

      // Draw X-axis labels (dates)
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      const labelCount = Math.min(5, values.length);
      for (let i = 0; i < labelCount; i++) {
        const idx = Math.floor((i / (labelCount - 1)) * (values.length - 1));
        const x = scaleX(idx);
        const date = values[idx].date;
        const label = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
        ctx.fillText(label, x, height - padding.bottom + 8);
      }

      // Draw invested line (dashed)
      ctx.strokeStyle = '#d4cfc4';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();

      values.forEach((v, i) => {
        const x = scaleX(i);
        const y = scaleY(v.invested);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw portfolio value line
      ctx.strokeStyle = '#a08c6d';
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();

      values.forEach((v, i) => {
        const x = scaleX(i);
        const y = scaleY(v.value);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();

      // Fill area between lines
      ctx.beginPath();
      values.forEach((v, i) => {
        const x = scaleX(i);
        const y = scaleY(v.value);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      for (let i = values.length - 1; i >= 0; i--) {
        const x = scaleX(i);
        const y = scaleY(values[i].invested);
        ctx.lineTo(x, y);
      }
      ctx.closePath();

      const isProfit = results.returnPercent >= 0;
      ctx.fillStyle = isProfit ? 'rgba(90, 122, 90, 0.15)' : 'rgba(139, 90, 90, 0.15)';
      ctx.fill();

      // Draw EMA overlay when in EMA mode
      if (results.isEma && results.emaData && results.emaData.length > 0) {
        const emaData = results.emaData;

        // Compute secondary Y-scale for price/EMA
        let priceMin = Infinity, priceMax = -Infinity;
        for (const d of emaData) {
          if (d.price < priceMin) priceMin = d.price;
          if (d.price > priceMax) priceMax = d.price;
          if (d.ema < priceMin) priceMin = d.ema;
          if (d.ema > priceMax) priceMax = d.ema;
        }
        // Add 5% padding
        const priceRange = priceMax - priceMin;
        priceMin -= priceRange * 0.05;
        priceMax += priceRange * 0.05;

        const scaleEmaX = (i) => padding.left + (i / (emaData.length - 1)) * chartWidth;
        const scaleEmaY = (v) => padding.top + chartHeight - ((v - priceMin) / (priceMax - priceMin)) * chartHeight;

        // Draw stock price line (muted blue)
        ctx.strokeStyle = '#8b9dc3';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        for (let i = 0; i < emaData.length; i++) {
          const x = scaleEmaX(i);
          const y = scaleEmaY(emaData[i].price);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Draw 200 EMA line (warm orange, dashed)
        ctx.strokeStyle = '#c4713b';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        for (let i = 0; i < emaData.length; i++) {
          const x = scaleEmaX(i);
          const y = scaleEmaY(emaData[i].ema);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Load ticker data and update UI
    async function loadTicker(symbol, yahooTicker) {
      resultsCard.classList.add('loading');
      stockPriceEl.textContent = 'Loading...';
      stockChangeEl.textContent = '';

      state.ticker = symbol;
      state.yahooTicker = yahooTicker;
      state.tickerData = await fetchStockData(yahooTicker);

      updateStockInfo();
      updateResults();
      resultsCard.classList.remove('loading');
    }

    // --- Ticker search dropdown ---
    function renderDropdown(filter) {
      const query = filter.toLowerCase();
      const matches = TICKERS.filter(t =>
        t.symbol.toLowerCase().includes(query) ||
        t.name.toLowerCase().includes(query)
      );

      tickerDropdown.innerHTML = '';
      matches.forEach(t => {
        const div = document.createElement('div');
        div.className = 'ticker-option';
        div.innerHTML = `<span class="ticker-symbol">${t.symbol}</span><span class="ticker-name">${t.name}</span>`;
        div.addEventListener('mousedown', (e) => {
          e.preventDefault();
          selectTicker(t);
        });
        tickerDropdown.appendChild(div);
      });

      if (matches.length > 0) {
        tickerDropdown.classList.add('open');
        tickerSearch.classList.add('has-focus');
      } else {
        tickerDropdown.classList.remove('open');
        tickerSearch.classList.remove('has-focus');
      }
    }

    function selectTicker(t) {
      state.ticker = t.symbol;
      tickerSearch.value = `${t.symbol} - ${t.name}`;
      tickerDropdown.classList.remove('open');
      tickerSearch.classList.remove('has-focus');
      tickerSearch.blur();
      loadTicker(t.symbol, t.yahoo);
    }

    tickerSearch.addEventListener('focus', () => {
      tickerSearch.value = '';
      renderDropdown('');
    });

    tickerSearch.addEventListener('input', () => {
      renderDropdown(tickerSearch.value);
    });

    tickerSearch.addEventListener('blur', () => {
      tickerDropdown.classList.remove('open');
      tickerSearch.classList.remove('has-focus');
      // Restore display value
      const current = TICKERS.find(t => t.symbol === state.ticker);
      if (current) {
        tickerSearch.value = `${current.symbol} - ${current.name}`;
      }
    });

    // Close dropdown on outside click
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.ticker-search-wrapper')) {
        tickerDropdown.classList.remove('open');
        tickerSearch.classList.remove('has-focus');
      }
    });

    // --- Other event listeners ---
    styleBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        styleBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.style = btn.dataset.style;

        if (state.style === 'dca') {
          amountLabel.textContent = 'Monthly Amount';
          amountHint.textContent = "Amount you'd invest each month";
          amountInput.value = '500';
          state.amount = 500;
        } else if (state.style === 'lump') {
          amountLabel.textContent = 'Initial Investment';
          amountHint.textContent = 'One-time investment amount';
          amountInput.value = '10000';
          state.amount = 10000;
        } else if (state.style.startsWith('ema')) {
          const period = state.style.replace('ema', '');
          amountLabel.textContent = 'Buy Amount per Signal';
          amountHint.textContent = `Amount to invest each time price touches ${period} EMA`;
          amountInput.value = '1000';
          state.amount = 1000;
        }

        updateResults();
      });
    });

    amountInput.addEventListener('input', (e) => {
      const value = e.target.value.replace(/[^0-9]/g, '');
      state.amount = parseInt(value) || 0;
      updateResults();
    });

    amountInput.addEventListener('blur', (e) => {
      if (state.amount > 0) {
        e.target.value = state.amount.toLocaleString();
      }
    });

    amountInput.addEventListener('focus', (e) => {
      e.target.value = state.amount || '';
    });

    yearsSlider.addEventListener('input', (e) => {
      state.years = parseInt(e.target.value);
      yearsDisplay.textContent = state.years;
      updateResults();
    });

    // Handle window resize for chart
    window.addEventListener('resize', updateResults);

    // Initial load
    const defaultTicker = TICKERS.find(t => t.symbol === 'VOO');
    tickerSearch.value = `${defaultTicker.symbol} - ${defaultTicker.name}`;
    loadTicker(defaultTicker.symbol, defaultTicker.yahoo);
  </script>
</body>
</html>
